## 1. 子集能否累加出k

### 题目

给定一个有正有负有零的数组和整数k，问数组的子集能否累加出k。

### 思路

- 把问题看作是一个最简单的背包问题。
- 使用动态规划，定义dp[i][g]为从0到i范围上的所有数字自由选择是否能累加出g。
- dp表填充true或false。
- 转移方程分为两种情况：不使用第i个数和必须使用第i个数。
- 处理负数时，通过平移来重新定义dp表的索引。

注意事项：

- 在处理有正有负有零的数组时，注意平移的概念以正确映射负数到非负索引。

## 2. 数组中的数值很大但长度不大时的解决方法

### 题目

如果数组中的数值很大但长度不大，如何判断子集能否累加出特定值？

### 思路

- 分支法：将数组分成两部分，每部分暴力计算所有可能的累加和。
- 对于40个数的情况，分成左右两半各20个数，暴力跑出所有可能的累加和（约100万种）。
- 合并左右部分的结果，遍历左边的累加和，在右边寻找配对的累加和。

注意事项：

- 分成多部分可以减少暴力解的数量，但整合逻辑会变得更复杂，通常两分即可。

## 3. 最小不能组成的正整数

### 题目

给定一个正数数组，返回不能由其子集累加出的最小正整数。

### 思路

- 先排序数组。
- 定义变量range，表示当前能够累加出的所有正整数范围。
- 遍历数组，若当前数大于range+1，则range+1就是无法组成的最小正整数。
- 否则，更新range为range加上当前数。
- 若遍历完数组仍未找到，则返回range+1。

注意事项：

- 判断是否包含1很重要，因为1是连续的基础，没有1直接返回1。

## 4. 补丁问题

### 题目

给定一个有序正数数组和目标n，返回最少需要补充多少个数才能使得1到n之间的所有数都能被组成。

### 思路

- 初始化range为0，补丁数为0。
- 遍历数组，对于每个数，若它大于range+1，则需要补充range+1这个数，并更新range。
- 更新range后检查是否超过目标n，若超过则返回补丁数。
- 使用完数组后，继续补充range+1直到达到目标n。

注意事项：

- 注意数据类型溢出问题，使用long类型可以避免此问题。