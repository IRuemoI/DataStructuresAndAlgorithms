## 1. 动态规划：最长有效括号子串

### 题目

给定一个只包含左括号和右括号的字符串，返回最长有效括号子串的长度。

### 思路

- **初始化**：创建一个数组`dp`，其中`dp[i]`表示以第`i`个字符结尾的最长有效括号子串的长度。

- 状态转移方程

  ：

  - 如果当前字符是左括号，`dp[i] = 0`。
  - 如果当前字符是右括号，寻找与之匹配的左括号，并更新`dp[i]`。
  - 具体地，如果`s[i-1-dp[i-1]] == '('`，则`dp[i] = dp[i-1] + 2`。
  - 再加上前面可能的有效括号长度：`dp[i] += dp[i-2-dp[i-1]]`（如果存在）。

- **结果**：遍历`dp`数组，找到最大值即为答案。

## 2. 前缀和与有序表：求子数组累加和最接近k

### 题目

返回数组中子数组的累加和，该累加和必须小于等于k，并且是最接近k的。

### 思路

- **前缀和**：计算从数组开始到当前位置的所有元素的累加和。
- **有序表查询**：对于每个位置的前缀和`sum`，在有序表中查询是否存在`sum - k`的值。
- **更新结果**：如果找到更接近k的值，更新结果。
- **时间复杂度**：O(n log n)，其中n为数组长度。

## 3. 完全二叉树节点计数

### 题目

给定一棵完全二叉树，计算其节点总数，要求时间复杂度低于O(n)。

### 思路

- **高度计算**：通过不断向左子节点移动，确定树的高度h。

- 递归计算

  ：

  - 如果右子树的最左节点到达最后一层，则左子树是满二叉树，直接计算节点数并递归右子树。
  - 否则，右子树是满二叉树，直接计算节点数并递归左子树。

- **复杂度分析**：每次递归减少一层，总复杂度为O(log^2 n)。

## 4. 最小缺失正整数

### 题目

在一个可能包含正数、负数和零的数组中，找到缺失的最小正整数。

### 思路

- **重排数组**：尝试将数字`i`放置到索引`i-1`的位置上。
- **遍历数组**：检查每个位置是否满足条件，如果不满足，则该位置的索引+1即为缺失的最小正整数。
- **特殊情况处理**：忽略大于数组长度或小于等于0的数字。
- **结果**：遍历完成后，第一个不满足条件的位置即为答案。

## 注意事项

- 在使用动态规划时，注意初始化和边界条件。
- 使用前缀和与有序表时，确保数据结构的操作正确，避免越界。
- 对于完全二叉树节点计数，理解递归逻辑和高度计算的重要性。
- 寻找最小缺失正整数时，注意数组重排的过程和特殊数值的处理。