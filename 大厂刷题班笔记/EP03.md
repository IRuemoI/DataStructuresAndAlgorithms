## 01 求与目标节点距离为K的所有节点 
### 题目
给定一棵二叉树的头节点、一个目标节点和正数K，返回所有与目标节点距离为K的节点。
 
### 思路 
- 生成父节点映射：通过递归遍历整棵树，构建每个节点到其父节点的映射关系。这样可以从任意节点向上或向下移动。
- 宽度优先搜索：从目标节点开始，利用队列进行宽度优先搜索，记录访问过的节点以避免重复访问。当搜索到距离为K的节点时，将其加入结果列表。
- 代码实现：通过递归函数构建父节点映射，使用队列进行宽度优先搜索，最终返回距离为K的所有节点。
 
## 02 最多比赛场次 
### 题目
给定一个数组表示每个人的能力值和非负整数K，如果两个人的能力差正好为K，则可以凑成一场比赛。求最多能有多少场比赛。
 
### 思路
- 排序数组：先对数组进行排序，以便后续利用单调性解决问题。
- 双指针法：使用两个指针l和r分别指向窗口的左右边界，根据当前两个指针所指元素的差值调整指针位置。
- 贪心策略：当找到一对满足条件的选手时，标记他们为已使用，并同时移动两个指针继续寻找下一对。
- 代码实现：初始化窗口边界，通过循环调整指针位置并计数符合条件的比赛场次。
 
## 03 字符串最长无重复子串长度
### 题目
求一个字符串中最长的无重复字符子串的长度。
 
### 思路
- 动态规划：定义状态dp[i]为以第i个字符结尾的最长无重复子串长度。通过比较当前字符上次出现的位置和前一个状态的结果来更新当前状态。
- 优化空间复杂度：由于只依赖前一个状态的结果，可以用有限几个变量代替整个dp数组。
- 代码实现：遍历字符串，维护一个记录字符上次出现位置的数组，利用动态规划思想计算每个位置的最大无重复子串长度，并更新全局最大值。
 
## 04 不同类别的字符串数量
### 题目
给定一些仅由小写字母组成的字符串，判断这些字符串中有多少种类别不同的字符串（类别定义为包含相同字母集的字符串）。
 
### 思路
- 位运算表示字母集合：用一个32位整数表示26个小写字母的出现情况，每一位对应一个字母是否出现过。
- 哈希表存储类别：将每个字符串转化为对应的整数表示，存入哈希表中。最终哈希表的大小即为不同类别的数量。
- 代码实现：遍历每个字符串，对其每个字符进行位运算得到整数表示，存入哈希表并统计类别数量。
 
## 05 边框全为1的最大正方形面积
### 题目
给定一个只含0和1的二维数组，求边框全为1的最大正方形面积。
 
### 思路
- 预处理数组：分别预处理每个点向右和向下的连续1的数量。
- 枚举正方形：枚举左上角顶点和边长，利用预处理信息在常数时间内验证正方形边框是否全为1。
- 优化验证过程：通过预处理数组，避免直接遍历正方形四周，从而降低时间复杂度。
- 代码实现：先预处理右信息和下信息，再通过三重循环枚举正方形顶点和边长，利用预处理信息快速验证并更新最大面积。
 
注意事项 
- 在解决与树相关的问题时，考虑如何利用额外的数据结构（如父节点映射）辅助解题。
- 对于涉及区间或窗口的问题，双指针法和贪心策略往往是有效的解决方案。
- 动态规划问题中注意状态定义和转移方程的设计，以及可能的空间优化。
- 位运算可以高效地处理集合相关的操作，尤其是在字母集合判定等场景中。
- 预处理技巧可以帮助减少重复计算，提高算法效率，在处理二维数组问题时尤为有用。