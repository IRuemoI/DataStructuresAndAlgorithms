## 79. 单词搜索
### 题目描述 
给定一个二维网格和一个单词，找出单词是否可以从网格中构成。每次只能移动到相邻的格子，并且不能重复使用同一个格子。

### 解题思路
- 定义递归函数`f(board, i, j, word, k)`，表示从`board[i][j]`出发能否匹配`word[k:]`。
- base case:
  * 如果`k == len(word)`，说明已经匹配完成，返回`True`。
  * 如果越界或者当前字符不匹配，返回`False`。
- 将当前位置字符保存并置为特殊值（如0），防止回头路。
- 对上下左右四个方向进行深度优先搜索。
- 恢复现场，将字符恢复原状。
- 主函数遍历每个位置，尝试触发递归。

---

## 88. 合并两个有序数组 
### 题目描述
将两个有序数组合并成一个有序数组，其中第二个数组有足够的空间容纳合并后的结果。

### 解题思路 
- 使用双指针法，分别指向两个数组的有效部分末尾。
- 从后向前填充目标数组，每次选择较大的元素放入。
- 如果有剩余元素，直接复制到目标数组的前面。
- 注意处理相等时的策略：先拷贝长数组中的元素以释放空间。

---

## 91. 解码方法
### 题目描述
给定一个只包含数字的字符串，计算有多少种解码方式。

### 解题思路
- 定义递归函数`f(s, index)`，表示从`s[index:]`开始有多少种解码方式。
- base case:
  * 如果`index == len(s)`，返回1。
  * 如果`s[index] == '0'`，返回0。
- 当前位置可以单独解码（1位数）或与下一位组合解码（2位数）。
- 如果组合数小于等于26，则累加两种情况的结果。
- 转换为动态规划，用一维数组存储中间结果以优化性能。

---

## 639. 解码方法 II
### 题目描述 
扩展版的解码问题，支持通配符`*`，表示任意数字1-9。

### 解题思路
- 定义递归函数`f(s, index)`，与91题类似。
- 处理`*`的情况：
  * 单独解码时，`*`有9种可能性。
  * 组合解码时，分情况讨论`*`与其他字符的组合。
    * 如果下一个字符是数字，根据范围判断组合是否有效。
    * 如果下一个字符也是`*`，枚举所有可能的组合。
- 转换为动态规划，注意取模操作以避免溢出。

---

## 98. 验证二叉搜索树
### 题目描述 
验证一棵树是否为二叉搜索树。

### 解题思路
- 中序遍历二叉树，检查是否严格递增。
- 如果使用Morris遍历：
  * 遇到冲突时不立即返回`False`，而是设置标志位并继续遍历。
  * 确保遍历完成后恢复树结构再返回结果。

---

## 101. 对称二叉树
### 题目描述
判断一棵树是否为镜像对称。

### 解题思路 
- 定义递归函数`isMirror(node1, node2)`，判断两棵子树是否互为镜像。
- base case:
  * 如果两节点都为空，返回`True`。
  * 如果只有一个为空，返回`False`。
- 递归检查：
  * `node1.val == node2.val`
  * `node1.left`与`node2.right`互为镜像
  * `node1.right`与`node2.left`互为镜像
- 主函数调用`isMirror(root.left, root.right)`。

---
## 103. 二叉树的锯齿形层序遍历
### 题目描述
按锯齿形顺序返回二叉树的层序遍历结果。

### 解题思路
- 使用队列实现层次遍历。
- 每一层记录节点数量，依次弹出并加入下一层节点。
- 根据层数奇偶性决定当前层结果的插入顺序（正序或逆序）。
- 可以使用双端队列优化插入操作。

---

## 108. 将有序数组转换为二叉搜索树 
### 题目描述
将一个有序数组转换为高度平衡的二叉搜索树。

### 解题思路
- 定义递归函数`buildTree(nums, l, r)`，表示用`nums[l:r+1]`构建子树。
- base case:
  * 如果`l > r`，返回`None`。
- 找到中间位置`m`作为根节点，递归构建左子树和右子树。
- 返回根节点。

---

## 116. 填充每个节点的下一个右侧节点指针
### 题目描述
给定一棵完美二叉树，填充每个节点的`next`指针，使其指向右侧的节点。

### 解题思路
- 使用层次遍历的思想，但不需要额外队列。
- 利用已填充的`next`指针辅助遍历。
- 对于每个节点：
  * 如果有左孩子，将其`next`指向右孩子。
  * 如果有右孩子且当前节点的`next`不为空，将右孩子的`next`指向当前节点`next`的左孩子。
- 从根节点开始，逐层处理。

---

注意事项 
- 在面试中尽量避免手写复杂数据结构（如红黑树），可以选择更简单的实现方式（如堆）。
- 动态规划问题建议从暴力递归入手，逐步优化至动态规划。
- Morris遍历时需注意恢复树结构，避免修改原始数据。
- 锯齿形层序遍历可以通过调整插入顺序实现，无需额外队列。
- 构建平衡二叉树时，选择中间位置作为根节点可确保平衡性。