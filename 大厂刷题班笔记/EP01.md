## 一根长度为K的绳子，最多能盖住几个点

题目：给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置。给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点。绳子的边缘点碰到X轴上的点，也算盖住

思路：

- **暴力解法**：两层循环枚举所有可能的区间，时间复杂度较高。
- **贪心 + 二分法**：
  - 将每个点视为绳子的右端点，计算左端点能覆盖的最远左边点。
  - 使用二分查找快速定位左边界，时间复杂度为 `O(n log n)`。
- **滑动窗口法**：
  - 维护一个窗口 `[left, right]`，确保窗口内的点能被绳子覆盖。
  - 每次移动左指针，右指针尽可能向右扩展，时间复杂度为 `O(n)`。

```csharp
private static int MaxPoint2(int[] arr, int l)
{
    var left = 0;
    var right = 0;
    var n = arr.Length;
    var max = 0;
    while (left < n)
    {
        while (right < n && arr[right] - arr[left] <= l) right++;
        max = Math.Max(max, right - left++);
    }

    return max;
}
```

## 统计目录下的文件数量

题目：给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回隐藏文件也算，但是文件夹不算

思路：

- **宽度优先搜索（BFS）**：
  - 使用队列存储文件夹，逐层展开。
  - 遇到文件则计数加一，遇到文件夹则加入队列。
  - 时间复杂度为 `O(n)`，其中 `n` 是文件和文件夹总数。
- **深度优先搜索（DFS）**：
  - 使用栈模拟递归行为，避免显式递归调用。
  - 同样区分文件和文件夹，分别处理。

```csharp
// 注意这个函数也会统计隐藏文件  
private static int GetFileNumber(string folderPath)
{
    var root = new DirectoryInfo(folderPath);
    if (!root.Exists) return 0;

    if ((File.GetAttributes(folderPath) & FileAttributes.Directory) !=
        FileAttributes.Directory) return 1; // 如果路径指向的是一个文件，返回1  


    var stack = new Stack<DirectoryInfo>();
    stack.Push(root);
    var files = 0;
    while (stack.Count > 0)
    {
        var folder = stack.Pop();
        var filesInfo = folder.GetFiles();
        // foreach (var file in filesInfo)
        // {
        //     files++;
        // }

        files += filesInfo.Length;

        var dirsInfo = folder.GetDirectories();
        foreach (var dir in dirsInfo) stack.Push(dir);
    }

    return files;
}

```

## 返回距离非负整数num最近的2某次方

题目：已知n是正数，返回大于等于，且最接近n的，2的某次方的值

思路：**位运算技巧**：

- 将 `member` 减一后，通过一系列或运算填满二进制中的所有低位。
- 最后加一即可得到最近的2的幂。
- 特殊处理负数情况，直接返回1。

```csharp
// 已知n是正数
// 返回大于等于，且最接近n的，2的某次方的值
private static int TableSizeFor(int n)
{
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return n < 0 ? 1 : n + 1;
}
```

## 相邻字符的交换次数

题目：一个数组中只有两种字符'G'和'B’，想让所有的G都放在左侧，所有的B都放在右侧，或者反过来。但是只能在相邻字符之间进行交换操作，返回至少需要交换几次。

思路：**贪心算法**：

- 维护一个指针 `l` 表示当前 `g` 应该放置的位置。
- 遍历数组，遇到 `g` 时计算需要移动的距离，并累加到总次数。
- 时间复杂度为 `O(n)`。

```csharp
private static int MinSteps1(string s)
{
    if (s is null or "") return 0;
    var str = s.ToCharArray();
    var step1 = 0;
    var gi = 0;
    for (var i = 0; i < str.Length; i++)
        if (str[i] == 'G')
            step1 += i - gi++;
    var step2 = 0;
    var bi = 0;
    for (var i = 0; i < str.Length; i++)
        if (str[i] == 'B')
            step2 += i - bi++;
    return Math.Min(step1, step2);
}
```

## 矩阵中的最长递增路径

题目：给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。  例子：  

matrix = $\begin{matrix} 5 & 4 & 3\\ 3 & 1 & 2\\ 2 & 1 & 3\\ \end{matrix}$

从最中心的1出发，是可以走出1 2 3 4 5的链的，而且这是最长的递增链。所以返回长度5

思路：

- **暴力递归**：
  - 从每个位置出发，递归尝试四个方向，时间复杂度过高。
- **记忆化搜索**：
  - 使用缓存记录每个位置的最长路径，避免重复计算。
  - 时间复杂度为 `O(mn)`，空间复杂度为 `O(mn)`。

```csharp
private static int LongestIncreasingPath2(int[][] matrix)
{
    var ans = 0;
    var n = matrix.Length;
    var m = matrix[0].Length;
    var dp = new int[n, m];
    for (var i = 0; i < n; i++)
        for (var j = 0; j < m; j++)
            ans = Math.Max(ans, Process2(matrix, i, j, dp));
    return ans;
}
// 从m[i][j]开始走，走出来的最长递增链，返回！
private static int Process(int[][] m, int i, int j, int[,] dp)
{
    if (dp[i, j] != 0) return dp[i, j];
    // (i,j)不越界
    var up = i > 0 && m[i][j] < m[i - 1][j] ? Process2(m, i - 1, j, dp) : 0;
    var down = i < m.Length - 1 && m[i][j] < m[i + 1][j] ? Process2(m, i + 1, j, dp) : 0;
    var left = j > 0 && m[i][j] < m[i][j - 1] ? Process2(m, i, j - 1, dp) : 0;
    var right = j < m[0].Length - 1 && m[i][j] < m[i][j + 1] ? Process2(m, i, j + 1, dp) : 0;
    var ans = Math.Max(Math.Max(up, down), Math.Max(left, right)) + 1;
    dp[i, j] = ans;
    return ans;
}
```

## 清空所有怪兽需要的AOE技能次数

题目：

思路：线段树优化

```csharp
// 贪心策略和方法二一样，但是需要用线段树，可优化成O(N * logN)的方法，
private static int MinAoe3(int[] x, int[] hp, int range)
{
    var n = x.Length;
    // coverLeft[i]：如果以i为中心点放技能，左侧能影响到哪，下标从1开始，不从0开始
    // coverRight[i]：如果以i为中心点放技能，右侧能影响到哪，下标从1开始，不从0开始
    // coverLeft和coverRight数组，0位置弃而不用
    // 举个例子，比如 :
    // x = [1,2,5,7,9,12,15], range = 3
    // 下标: 1 2 3 4 5 6 7
    // 以1位置做中心点: 能覆盖位置:1,2 -> [1..2]
    // 以2位置做中心点: 能覆盖位置:1,2,3 -> [1..3]
    // 以3位置做中心点: 能覆盖位置:2,3,4 -> [2..4]
    // 以4位置做中心点: 能覆盖位置:3,4,5 -> [3..5]
    // 以5位置做中心点: 能覆盖位置:4,5,6 -> [4..6]
    // 以6位置做中心点: 能覆盖位置:5,6,7 -> [5..7]
    // 以7位置做中心点: 能覆盖位置:6,7 -> [6..7]
    // 可以看出如果从左往右，依次求每个位置的左边界(left)和左边界(right)，是可以不回退的！
    var coverLeft = new int[n + 1];
    var coverRight = new int[n + 1];
    var left = 0;
    var right = 0;
    // 从左往右，不回退的依次求每个位置的左边界(left)和左边界(right)，记录到coverLeft和coverRight里
    for (var i = 0; i < n; i++)
    {
        while (x[i] - x[left] > range)
            left++;
        while (right < n && x[right] - x[i] <= range)
            right++;
        coverLeft[i + 1] = left + 1;
        coverRight[i + 1] = right;
    }

    // best[i]: 如果i是最左边缘点，选哪个点做技能中心点最好，下标从1开始，不从0开始
    // 与上面同理，依然可以不回退
    var best = new int[n + 1];
    var trigger = 0;
    for (var i = 0; i < n; i++)
    {
        while (trigger < n && x[trigger] - x[i] <= range)
            trigger++;
        best[i + 1] = trigger;
    }

    var st = new SegmentTree(hp);
    st.Build(1, n, 1);
    var ans = 0;
    // 整体思路：
    // 当前左边缘点从i位置开始(注意0位置已经弃而不用了)，
    // 目标是把左边缘的怪物杀死，但是放技能的位置当然是尽可能远离左边缘点，但是又保证能覆盖住
    // best[i] : 放技能的位置当然是尽可能远离左边缘点i，但是又保证能覆盖住，
    // 请问这个中心在哪？就是best的含义，之前求过了。
    // 然后在这个中心点，放技能，放几次技能呢？左边缘点还剩多少血，就放几次技能，
    // 这样能保证刚好杀死左边缘点。
    // 然后向右继续寻找下一个没有死的左边缘点。
    for (var i = 1; i <= n; i++)
    {
        // 查询当前i位置，还有没有怪物存活
        var leftEdge = st.Query(i, i, 1, n, 1);
        // 如果还有血量(leftEdge > 0)，说明有存活。此时，放技能
        // 如果没有血了(leftEdge <= 0)，说明当前边缘点不需要考虑了，换下一个i
        if (leftEdge > 0)
        {
            // t = best[i]: 在哪放技能最值
            // l = coverLeft[t]: 如果在t放技能的话，左边界影响到哪
            // r = coverRight[t]: 如果在t放技能的话，右边界影响到哪
            // 就在t放技能，放leftEdge次，这样左边缘点恰好被杀死
            ans += (int)leftEdge;
            var t = best[i];
            var l = coverLeft[t];
            var r = coverRight[t];
            // 同时[l...r]整个范围，所有的怪物都会扣除掉leftEdge的血量，因为AOE嘛！
            st.Add(l, r, (int)-leftEdge, 1, n, 1);
        }
    }

    return ans;
}
```

## 数组中添加加减运算符得到指定值的所有方法

题目：给定一个数组，每个元素前可以添加加号或减号，求所有可能的组合中能达成目标值 `target` 的方法数。

思路：

- **暴力递归**：
  - 递归尝试每个位置选择加号或减号，时间复杂度为 `O(2^n)`。
- **记忆化搜索（动态规划）**：
  - 使用缓存记录 `(index, rest)` 的组合结果，避免重复计算。
  - 时间复杂度大幅降低，空间复杂度增加。
- **背包问题转化**：
  - 将问题转化为求子集和问题，使用动态规划求解。
  - 优化空间复杂度为 `O(sum)`。

```csharp
// 优化点一 :
// 你可以认为arr中都是非负数
// 因为即便是arr中有负数，比如[3,-4,2]
// 因为你能在每个数前面用+或者-号
// 所以[3,-4,2]其实和[3,4,2]达成一样的效果
// 那么我们就全把arr变成非负数，不会影响结果的
// 优化点二 :
// 如果arr都是非负数，并且所有数的累加和是sum
// 那么如果target<sum，很明显没有任何方法可以达到target，可以直接返回0
// 优化点三 :
// arr内部的数组，不管怎么+和-，最终的结果都一定不会改变奇偶性
// 所以，如果所有数的累加和是sum，
// 并且与target的奇偶性不一样，没有任何方法可以达到target，可以直接返回0
// 优化点四 :
// 比如说给定一个数组, arr = [1, 2, 3, 4, 5] 并且 target = 3
// 其中一个方案是 : +1 -2 +3 -4 +5 = 3
// 该方案中取了正的集合为P = {1，3，5}
// 该方案中取了负的集合为N = {2，4}
// 所以任何一种方案，都一定有 sum(P) - sum(N) = target
// 现在我们来处理一下这个等式，把左右两边都加上sum(P) + sum(N)，那么就会变成如下：
// sum(P) - sum(N) + sum(P) + sum(N) = target + sum(P) + sum(N)
// 2 * sum(P) = target + 数组所有数的累加和
// sum(P) = (target + 数组所有数的累加和) / 2
// 也就是说，任何一个集合，只要累加和是(target + 数组所有数的累加和) / 2
// 那么就一定对应一种target的方式
// 也就是说，比如非负数组arr，target = 7, 而所有数累加和是11
// 求有多少方法组成7，其实就是求有多少种达到累加和(7+11)/2=9的方法
// 优化点五 :
// 二维动态规划的空间压缩技巧
private static int FindTargetSumWays(int[] arr, int target)
{
    var sum = 0;
    foreach (var n in arr) sum += n;

    return sum < target || ((target & 1) ^ (sum & 1)) != 0 ? 0 : Subset2(arr, (target + sum) >> 1);
}

// 求非负数组numbers有多少个子集，累加和是s
// 二维动态规划
// 用空间压缩:
// 核心就是for循环里面的：for (int i = s; i >= n; i--) {
// 为啥不枚举所有可能的累加和？只枚举 n...s 这些累加和？
// 因为如果 i - n < 0，dp[i]怎么更新？和上一步的dp[i]一样！所以不用更新
// 如果 i - n >= 0，dp[i]怎么更新？上一步的dp[i] + 上一步dp[i - n]的值，这才需要更新
private static int Subset2(int[] numbers, int s)
{
    if (s < 0) return 0;
    var dp = new int[s + 1];
    dp[0] = 1;
    foreach (var n in numbers)
        for (var i = s; i >= n; i--)
            dp[i] += dp[i - n];

    return dp[s];
}
```

### 注意事项

- **动态规划**：适用于有重叠子问题和最优子结构的问题，注意状态转移方程的设计。
- **贪心算法**：需验证贪心选择的正确性，通常通过对比暴力解法验证。
- **线段树**：适用于区间更新和查询问题，注意懒惰标记的使用。
- **滑动窗口**：适用于有序数组的区间问题，确保窗口内的元素满足条件。
- **记忆化搜索**：通过缓存减少重复计算，适用于递归中有大量重复状态的情况。
