## 1. 字符串至少需要添加多少个字符，能让它整体变成回文串

### 题目

给定一个字符串，求至少需要添加多少个字符才能使该字符串变为回文串。

### 思路

- **动态规划表的构建**：定义f(l, r)为将字符串从位置l到r变为回文串所需的最少添加字符数。初始化对角线为0（单个字符本身就是回文）。对于倒数第二条对角线，如果两个字符相等则为0，否则为1。

- 填充动态规划表

  - 如果s[l] == s[r]，那么f(l, r) = f(l+1, r-1)。
  - 否则，f(l, r) = min(f(l+1, r), f(l, r-1)) + 1。

- **返回结果**：最终答案为f(0, n-1)，其中n是字符串长度。

## 2. 返回一种添加结果

### 题目

在上一题的基础上，不仅要求出最少添加字符数，还需要返回一种具体的添加方案。

### 思路

- 利用动态规划表回溯

  - 从动态规划表的右上角开始回溯，根据动态规划表中的值来决定路径。
  - 如果当前格子的值来自于左方或下方，则分别处理相应的字符添加。
  - 当l等于r时，表示只剩下一个字符未处理，直接添加到结果中。

- 具体步骤

  - 初始化左右指针l和r，以及结果字符串answer。
  - 在while循环中，根据l和r的关系及动态规划表的值进行回溯。
  - 最终得到一种添加方案。

## 3. 返回所有可能的添加结果

### 题目

在第一题的基础上，返回所有可能的最少添加字符方案。

### 思路

- 深度优先搜索

  - 从动态规划表的右上角开始，递归地探索所有可能的路径。
  - 每次选择一个方向（左或下）进行深入，直到l大于等于r。
  - 当l等于r时，将当前字符添加到结果中。

- 具体步骤

  - 使用递归函数，每次尝试不同的分支，将每种可能的结果存储在列表中。
  - 最终返回所有可能的添加方案。

## 4. 字符串至少要切几刀，能让切出来的子串都是回文串

### 题目

给定一个字符串，求至少需要切几刀才能使每个切出来的子串都是回文串。

### 思路

- 预处理回文检查表

  - 构建一个二维表map，用于快速判断任意子串是否为回文。
  - 初始化对角线为true（单个字符是回文），倒数第二条对角线根据字符是否相等赋值。
  - 其他格子根据两端字符是否相等及中间子串是否为回文来赋值。
  
- 动态规划求解

  - 定义dp[i]为从位置i到字符串末尾所需最小切割次数。
  - 初始化dp[n] = 0（空字符串不需要切割）。
  - 从后往前填充dp表，若从i到j是回文，则dp[i] = min(dp[i], dp[j+1] + 1)。
  
- **返回结果**：最终答案为dp[0] - 1（部分数减一即为刀数）。

### 注意事项

- 动态规划表的构建过程中要注意初始化和边界条件。
- 回溯时需注意左右指针的变化及终止条件。
- 在深度优先搜索中，确保恢复现场以避免影响其他分支的结果。
- 预处理回文检查表可以显著降低时间复杂度，避免重复计算。