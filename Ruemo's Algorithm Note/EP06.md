# [堆和堆排序](https://www.bilibili.com/video/BV1xdvaeEEjJ)

## 比较器

1. 比较器的实质就是运算符的重载
2. 比较器可以很好的应用在特定标准的排序上
3. 比较器可以很好的应用在根据特殊标准排序的结构上
4. 简化编码过程，也可用户泛型编程
5. 比较器的原则，返回负数时，第一个参数排在前面；返回正数时，第二个参数排在前面；返回0时，两参数的先后无所谓。

C#代码举例

~~~ c#
~~~

## 堆

1. 堆结构就是用数组实现的完全二叉树结构

   ​	完全二叉树：如果一个二叉树包含所有的同层次最下层的所有节点，或者最下层从左向右的增加节点就是完全二叉树。同时空二叉树也是完全二叉树。

   ​	使用数组结构存储完全二叉树：对于从零开始存储在数组结构中的完全二叉树中的节点的下标为$I$，该节点的左侧子节点的在数组中的下标为$2\times I+1$，该节点的右侧子节点的在数组中的下标为$2\times I+2$。该节点的父节点在数组中的下标为$int(\frac {I-1}{2})$。同时这个结构中包含一个变量size用于记录数组中存储的最后一个有效元素的位置。

2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆；完全二叉树中如果每棵子树的最小值都在顶部就是小根堆

3. 堆排序的heapinsert和heapify操作

   heapinsert：当处理大根堆时，首先将新插入的节点插入数组的末尾，然后与本节点的父节点进行比较，如果当前节点大于父节点时，与父节点交换位置，然后再次比较交换后的节点与新的父节点，直到新插入的节点无法向上交换位置。处理小根堆时同理，直到无法小于待比较的父节点，而终止交换为止。这种操作的执行的最大次数只和二叉树的高度有关，时间复杂度为$O(\log N)$ 。

   heapify：返回并删除最上方的元素，并且整理堆结构，使得组数保持堆结构的特性。

   ​	整理过程：	
   
   ​		对于大根堆：使用临时变量记录堆顶元素，将数组最后一个元素复制到堆顶，堆的size-1。之后让堆顶部的元素向两个子节点中较大一方下沉，直到超出范围或者无法小于左右两个中任意一个节点。
   
   ​		对于小根堆：使用临时变量记录堆顶元素，将数组最后一个元素复制到堆顶，堆的size-1。之后让堆顶部的元素向两个子节点中较小一方下沉，直到超出范围或者无法大于左右两个中任意一个节点。

   ​	这种操作的执行的最大次数只和二叉树的高度有关，时间复杂度为$O(\log N)$

   ~~~ c#
   //大根堆处理
   private void Heapify(int[] arr,int index,int heapSize)
   {
       int left = index * 2 + 1;
       while(left < heapSize)
       {
           //选出较大的孩子
           int largest = left + 1 > heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
           int maxIndex = arr[largest] > arr[index] ? largest :index;
           if(maxIndex == index)
           {
               break;
           }
           swap(arr,largest,index);
           index = largest;
           left = index * 2 + 1;
       }
   }
   //小根堆处理
   ~~~
   
   关于堆中有一个元素的放置的位置不正确的问题：对这个元素依次使用heapinsert和heapify。
   
4. 堆结构的增大和减少

5. 优先级队列结构就是堆结构

扩展：

* 优先级队列是使用堆结构实现的

* 一般语言内置的都是小根堆，如果要实现大根堆，可以在插入数据使用之间通过重新定义排序规则来实现。但是C#没有小根堆。

## 堆排序

从上到下建堆：现有一个无序数组，堆排序的方式是每次将数组中待处理的下一个元素加入堆（heapInsert，时间复杂度为$O(N\times \log N)$）中将整个数组变为大根堆。每次从堆中取出（heapify，时间复杂度为$O(N\times \log N)$）元素，将取出的元素从数组的尾部向数组的头部进行放置。

从下到上建堆：思路是先将底部子树构成大根堆，然后向上延伸将待排序的数组看做一个还构成大根堆的完全二叉树。从最下层开始heapify，完成之后，上层依次执行heapify。若一个完全二叉树的节点数为N，那么最下层最多有$\frac n 2$个节点。并且不参与节点移动，倒数第二层有$\frac n4$，最多需要移动2层。时间复杂度收敛到$O(N)$

~~~ c#
//从上到下
private static void HeapSortCode(int[]? arr)
    {
        if (arr == null || arr.Length < 2)
        {
            return;
        }
        // O(N*logN)
		for (int i = 0; i < arr.Length; i++) { // O(N)
			heapInsert(arr, i); // O(logN)
		}
        int heapSize = arr.Length;
        Swap(arr, 0, --heapSize);
        // O(N*logN)
        while (heapSize > 0)
        {
            // O(N)
            Heapify(arr, 0, heapSize); // O(logN)
            Swap(arr, 0, --heapSize); // O(1)
        }
    }
//从下到上
private static void HeapSortCode(int[]? arr)
    {
        if (arr == null || arr.Length < 2)
        {
            return;
        }
        // O(N)
        for (int i = arr.Length - 1; i >= 0; i--)
        {
            Heapify(arr, i, arr.Length);
        }
        int heapSize = arr.Length;
        Swap(arr, 0, --heapSize);
        // O(N*logN)
        while (heapSize > 0)
        {
            // O(N)
            Heapify(arr, 0, heapSize); // O(logN)
            Swap(arr, 0, --heapSize); // O(1)
        }
    }
~~~



题目：已知一个几乎有序的数组，几乎有序是指，如果把数字排好序，每个元素移动的距离一定不超过K，并且K相对于数组的长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。

解题方法：规定一个容量等于K的小根堆，一开始将0，k-1的元素放到堆中，之后将堆中最上层的元素取出，从左侧向右侧放置，小根堆放入右侧的下一个数字，小根堆会呈现向右移动的情况，小根堆右侧抵达数组的右侧后依次取出所有是数据即可。本方法的时间复杂度为$O(N\times \log K)$。

