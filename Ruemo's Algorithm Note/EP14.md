# [贪心算法2](https://www.bilibili.com/video/BV1AFvYe1ERF)

问题一：在一个班级里有N个同学， 有些同学是朋友，有些不是。他们之间的友谊是可以传递的比如A和B是朋友，B和C是朋友，那么A和C也是朋友。我们定义 **friend circle为由直接或者间接都是朋友组成的group**.给定\[N,N\]数组 M 代表同学之间的关系. 如果M\[i\] = 1, 那么i 和 j 同学是朋友，现在我们需要输出friend circles 的数量。
思路：按照上三角矩阵进行遍历(不包含对角线)。将相互认识的人合并为一个集合，在这这期间统计集合的数量。
注意：help数组用于记录从子节点到代表节点之间所有在路径的节点。然后回头把沿途的每一个数字都修改成最后一个代表节点。
问题二：给定一个二维数组，里面的值不是0就是1，上下左右相邻为1的就认为是一片岛。返回二维数组中岛的数量。
思路1：感染法，将二维数组按行遍历，将每个为1格子的上下左右进行递归，每个为1的节点改为2，2和0的节点直接返回。递归完成后小岛数量加一。完成上述步骤后从下一个节点开始如果遇到0或者2跳过。依次按行遍历完矩阵的每个元素。最后返回小岛的数量。参考方法3
思路2：并查集：初始情况下认为所有的1都是 独立的集合。每次碰到为1的格子都尝试与左方和上方的为1的格子进行合并，遇到0跳过。参考方法1，优化后参考方法2
问题三：给定一个m行，n列的二位数组，现有一个二位数组，数组中的每个元素是地图中新的被定义为小岛位置的坐标。返回每次新的位置被定义为小岛时，地图中包含独立小岛的个数。
思路：进行每步计算时建集合，使用size的非零值表示改位置已经被处理过。参考方法二。对二维数组行数和列数较大的进行优化参考unionfind2数据结构
题目四：对于第二题，如果二维数组的面积很大，设计用一种并行的计算方案。
思路：分区块进行计算，每个区块链记录每个形成岛的编号(每个区块不重复)，以及该编号下的边界格子。合并结果时根据每个区块的结果信息进行合并