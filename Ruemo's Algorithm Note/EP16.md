## [图部分](https://www.bilibili.com/video/BV1sfvaejEyr)

**图基础**

* 有向图与无向图

* 邻接表和邻接矩阵

* 理解代码中给出的点、边、图定义

**宽度优先遍历**

在二叉树的层次遍历的基础上添加一个集合保存已经遍历过的节点。

**深度优先遍历**

一条路走到黑，然后返回到没有这个遍历中的序列中的节点旁边未遍历的节点。直到图遍历完成。需要使用栈和集合。

**拓扑排序**

前提：有向无环图

比如在编译时需要先将依赖编译完成后才能进行编译。拓扑排序的结果就是给出一个正确的处理顺序。且正确的结果一般不唯一

1. 在图中找到所有入度为0的点输出
2. 把所有入度为0的点在图中删掉,继续找入度为0的点输出,周而复始
3. 图的所有点都被删除后,依次输出的顺序就是拓扑排序
   要求:有向图且其中没有环
   应用:事件安排、编译顺序
   orderdfs2点次排序
   orderdfs1最大深度排序

**克鲁斯卡尔算法**

每次选择权值最小的节点合并到现有集合，知道所有点被合并到集合

前提：无向有权图

1. 总是从权值最小的边开始考虑,依次考察权值依次变大的边
2. 当前的边要么进入最小生成树的集合,要么丢弃
3. 如果当前的边进入最小生成树的集合中不会形成环,就要当前边
4. 如果当前的边进入最小生成树的集合中会形成环,就不要当前边
5. 考察完所有边之后,最小生成树的集合也得到了
   使用并查集，解决最小生成树。

**普里姆算法**

从图中的某一点出发，每次选择下一个不会形成环的权值最小的边。解锁下一篇相邻的边。

1. 可以从任意节点出发来寻找最小生成树
2. 某个点加入到被选取的点中后,解锁这个点出发的所有新的边
3. 在所有解锁的边中选最小的边,然后看看这个边会不会形成环
4. 如果会,不要当前边,继续考察剩下解锁的边中最小的边,重复步骤3
5. 如果不会,要当前边,将该边的指向点加入到被选取的点中,重复步骤2
6. 当所有点都被选取,最小生成树就得到了

**迪杰斯特拉算法**

通过不断利用之间已经得出的距离加上下一个节点来替换最小距离，从而的得出起点与其他各个点的距离

1. Dijkstra算法必须指定一个源点   
2. 生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大  
3. 从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步  
4. 源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了  
   使用加强堆
   优化代码