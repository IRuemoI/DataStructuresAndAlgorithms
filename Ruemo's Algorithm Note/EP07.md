# [加强堆](https://www.bilibili.com/video/BV14dvaeEEND)

## 最大线段重合问题(用堆来实现)

给定很多线段，每个线段都有两个数组\[start,end\],表示线段开始和结束的位置，左右都是闭区间，规定：1.线段的开始和结束的位置一定都是整数；2.线段重合区域的长度必须大于等于1。返回线段最多重合区域中，包含了几条线段。

解题思路：
1. 根据线段的起始位置由小到大排好序
2. 准备好一个小根堆
3. 访问要添加进入堆的下一个线段前，先弹出堆中所有比将要添加线段的开始位置小的所有值。之后把要添加的线段的结束位置加入堆中（==目的是为了找到线段之间重合的部分==）
4. 最终的结果为小根堆的数量的最大值就是所求值(==也就是有几个重合的线段最大值，这个值需要替换记录一下==)
代码参考：CoverMax

## 需要手动改写堆的题目
系统提供的堆无法做到的事情
* 已经入堆的元素，如果参与排序的目标变量(比如对象的属性)变化，系统提供的堆无法做到在时间复杂度$\log_{} N$完成调整。
* 系统提供的堆只能弹出堆顶，做不到自由删除堆中的任意一个元素。
* 无法在时间复杂度$O(\log _{} N)$内完成
* 没有反向索引表
加强堆代码参考：HeapGreater(
基础类型可以使用Inner\<T\>包装
resign表示更改在某个堆中某个元素更改后重新整理堆，使得堆保持有序
删除任意一个元素后将这个元素和最后一个交换，堆大小减小，进行堆化。
)

题目二：

给定一个整型数组,int\[\] arr;和一个布尔类型数组,bool\[\] op。两个数组一定等长,假设长度为N, arr\[i\]表示客户编号,op\[i\]表示客户操作。

arr=\[3,3,1,2,1,2,5...\]

op=\[T,T,T,T,F,T,F...\]

依次表示:3号用户购买了一件商品,3号用户购买了一件商品,1号用户购买了一件商品,2号用户购买了一件商品,1号用户退货了一件商品,2号用户购买了一件商品,5号用户退货了一件商品...
一对arr\[i\]和op\[i\]就代表一个事件：
用户号为arr\[i\],op\[\i\]为T就代表这个用户购买了一件商品,op\[i\]为F就代表这个用户退货了一件商品。现在你作为电商平台负责人,你想在每一个事件到来的时候,都给购买次数最多的前K名用户颁奖。所以每个事件发生后,你都需要一个得奖名单(得奖区)。

得奖系统的规则:
1. 如果某个用户购买商品数为0,但是又发生了退货事件则认为该事件无效,得奖名单和上一个时间发生后一致,比如例子中的5号用户。
2. 某用户发生购买商品事件,购买商品数+1,发生退货事件,购买商品数-1。
3. 每次都是最多K个用户得奖,K也为传入的参数如果根据全部规则,得奖人数确实不够K个,那就以不够的情况输出结果
4. 得奖系统分为得奖区和候选区,任何用户只要购买数>0,一定在这两个区域中的一个
5. 购买数最大的前K名用户进入得奖区在最初时如果得奖区没有到达K个用户,那么新来的用户直接进入得奖区
6. 如果购买数不足以进入得奖区的用户,进入候选区
7. 如果候选区购买数最多的用户,已经足以进入得奖区该用户就会替换得奖区中购买数最少的用户(大于才能替换),如果得奖区中购买数最少的用户有多个,就替换最早进入得奖区的用户如果候选区中购买数最多的用户有多个,机会会给最早进入候选区的用户
8. 候选区和得奖区是两套时间,因用户只会在其中一个区域,所以只会有一个区域的时间,另一个没有从得奖区出来进入候选区的用户,得奖区时间删除。进入候选区的时间就是当前事件的时间(可以理解为arr们和op\[i\]中的i)；从候选区出来进入得奖区的用户,候选区时间删除。进入得奖区的时间就是当前事件的时间(可以理解为arr\[i\]和op\[i\]中的i)
9. 如果某用户购买数为0,不管在哪个区域都离开,区域时间删除,离开是指彻底离开,哪个区域也不会找到该用户如果下次该用户又发生购买行为,产生>0的购买数会再次根据之前规则回到某个区域中,进入区域的时间重记

**要求**：请遍历arr数组和op数组,遍历每一步输出一个得奖名单

public List<List\<Integer\>> topK (int\[\] arr, bool\[\] op, int k)

代码参考EveryStepShowBoss(
其中cands为候选区，dady为得奖区
比较条件 P08@02:25:13
加强堆方法：who's your dady
candidate
awardee
)