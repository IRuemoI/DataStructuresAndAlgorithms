# [前缀树、不基于比较的排序、排序稳定性](https://www.bilibili.com/video/BV1KdvaeEENh)

**前缀树**

1. 单个字符串中,字符从前到后的加到一棵多叉树上
2. 字符放在路上,节点上有专属的数据项(常见的是pass和end值)
3. 所有样本都这样添加,如果没有路就新建,如有路就复用
4. 沿途节点的pass值增加1,每个字符串结束时来到的节点end值增加1
可以完成前缀相关的查询
代码参考trieTree
**不基于比较的排序**
计数排序和基数排序
1)一般来讲,计数排序要求,样本是整数,且范围比较窄
2)一般来讲,基数排序要求,样本是10进制的正整数
一旦要求稍有升级,改写代价增加是显而易见的



**计数排序**
计数排序是一种非比较型排序算法，它的工作原理是对于给定的输入数据，将其映射至一个足够大的数组中，然后根据每个元素的值对其进行排序。在C#中实现计数排序，可以按照以下步骤进行：

1. 初始化一个数组（称为“计数数组”），大小应该足以容纳最大的输入值加上一（例如，如果数值范围是0到20，则数组大小应为21）。
2. 遍历原始数据中的每个元素，并增加计数数组中相应位置的计数。
3. 将计数数组中的元素重新排列，将0索引位置的元素放到最后。
4. 再次遍历计数数组，根据每个元素的值从数组中取出对应的原始数据元素，并存入一个新的数组中。
5. 返回新的数组，该数组即为已排序的数据。

```csharp
using System;
using System.Collections.Generic;

public class CountingSort
{
    public static int[] Sort(int[] arr, int maxVal)
    {
        // Step 1: 初始化计数数组
        List<int> countArray = new List<int>(maxVal + 1);

        // Step 2: 填充计数数组
        foreach (int num in arr)
        {
            countArray.Add(1); // 由于计数是基于1的，所以每个元素的计数都是1
        }

        // Step 3: 根据计数重排元素
        for (int i = 0; i < countArray.Count; i++)
        {
            countArray[i] += countArray[i - 1];
        }

        // Step 4: 收集最终排序好的数据
        List<int> sortedList = new List<int>(arr.Length);
        for (int i = arr.Length - 1; i >= 0; i--)
        {
            sortedList.Add((arr[i] + countArray[arr[i]] - 1));
            countArray[arr[i]]--;
        }

        // Step 5: 返回排序后的数组
        return sortedList.ToArray();
    }

    public static void Main()
    {
        int[] inputArray = { 5, 3, 7, 2, 6, 9, 1, 4, 8, 0, 20 };
        int maxVal = 20;
        int[] sortedArray = Sort(inputArray, maxVal);

        Console.WriteLine("排序后的数组: ");
        foreach (int val in sortedArray)
        {
            Console.Write(val + " ");
        }
    }
}
```

这段代码实现了计数排序算法，能够对一个整数数组进行排序，数值范围为0到20。在`Main`方法中创建了一个包含随机整数的数组，并调用了`Sort`方法来排序这个数组。最后，程序输出了排序后的数组。

**基数排序**

基数排序是一种非比较型整数排序算法，它通过将待排序的数据拆分成多个数字位进行排序。以下是使用C#实现基数排序的一个简单示例：

```csharp
public class RadixSort
{
    private static void RadixSort(int[] numbers)
    {
        if (numbers == null || numbers.Length <= 1)
        {
            return;
        }

        int max = numbers;
        for (int i = 1; i < numbers.Length; i++)
        {
            if (numbers[i] > max)
            {
                max = numbers[i];
            }
        }

        int exp = 1;
        while (max / exp > 0)
        {
            CountingSort(numbers, exp);
            exp *= 10;
        }
    }

    private static void CountingSort(int[] numbers, int exp)
    {
        int[] count = new int;
        for (int i = 0; i < numbers.Length; i++)
        {
            count[(numbers[i] / exp) % 10]++;
        }

        int[] result = new int[numbers.Length];
        for (int i = 0; i < 10; i++)
        {
            for (int j = 0; j < count[i]; j++)
            {
                result[result.Length - count[i] - 1] = i * exp + j;
            }
        }

        for (int i = 0; i < numbers.Length; i++)
        {
            numbers[i] = result[i];
        }
    }
}
```

在这个例子中，`RadixSort` 类包含两个方法：`RadixSort` 和 `CountingSort`。`RadixSort` 方法用于对整数数组进行基数排序，而 `CountingSort` 方法用于在给定的基数上进行计数排序。

`RadixSort` 方法首先检查输入数组是否为空或长度小于等于1，如果是，则返回。然后，它查找数组中的最大值，并根据该值确定基数。最后，它调用 `CountingSort` 方法，以每个基数为基础对数组进行排序，直到所有位数都被排序。

`CountingSort` 方法使用计数排序算法，这是一种稳定的排序算法，它通过创建一个计数数组来实现。对于每个基数，计数数组中的相应位置表示在该基数出现的次数。然后，该方法使用计数数组中的信息来构建一个新的已排序数组。

你可以使用以下代码调用 `RadixSort` 方法：

```csharp
int[] numbers = { 39, 38, 45, 26, 49, 27, 47, 28, 35 };
RadixSort.RadixSort(numbers);
foreach (int num in numbers)
{
    Console.WriteLine(num);
}
```

这将输出已排序的数组。 代码参考RadixSort

**排序的稳定性**
稳定性是指同样大小的样本再排序之后不会改变相对次序
对基础类型来说,稳定性毫无意义
对非基础类型来说,稳定性有重要意义
有些排序算法可以实现成稳定的,而有些排序算法无论如何都实现不成稳定的


**排序算法总结**

1. 不基于比较的排序,对样本数据有严格要求,不易改写
2. 基于比较的排序,只要规定好两个样本怎么比大小就可以直接复用
3. 基于比较的排序,时间复杂度的极限是$O(N\times\log_{} N)$
4. 时间复杂度$O(N\times \log_{} N)$、额外空间复杂度低于$O(N)$、且稳定的基于比较的排序是不存在的。
5. 为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并

| 算法 | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| :----: | -----: | -----: | :----: |
|选择排序| $O(N^2)$ | $O(1)$ | 无 |
| 冒泡排序 | $O(N^2)$ | $O(1)$ | 有 |
| 插入排序 | $O(N^2)$ | $O(1)$ | 有 |
| 归并排序 | $O(N\times\log_{} N)$ | $O(N)$ | 有 |
| 随机快排 | $O(N\times\log_{} N)$ | $O(\log_{} N)$ | 无 |
| 堆排序 | $O(N\times\log_{} N)$ | $O(1)$ | 无 |
| 计数排序 | $O(N)$ | $O(M)$ | 有 |
| 基数排序 | $O(N)$ | $O(N)$ | 有 |

常见的坑

1. 归并排序的额外空间复杂度可以变成$O(1)$，“归并排序内部缓存法”，但是讲使其变得不在稳定
2. “原地归并排序”会让时间复杂度编程$O(N^2)$
3. 快速排序稳定性改进的方案之一是“01 stable sort”，但是会对样本数据要求更多
4. 在整形数组中，请把奇数放在数组的左边，偶数放在数组的右边，要求都有奇数之间的于是相对次序不变，所有偶数之间的原始相对次序不变。要求世间爱你复杂度，额外空间复杂度为。这种情况非常苛刻需要用到“01 stable sort”

工程上堆排序的改进
1. 确定性的考虑
2. 充分利用$O(N\times\log_{}N)$和$O(N^2)$类排序各自的优势。比如使用多种排序方法来实现应对不同数据规模的分段函数来保证运行效率。