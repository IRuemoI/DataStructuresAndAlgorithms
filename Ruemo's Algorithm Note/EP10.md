# [二叉树基本算法1](https://www.bilibili.com/video/BV1xdvaeEEiV)

**二叉树**

二叉树的遍历 参考RecursiveTraversalBT

* 先序遍历:任何子树的处理顺序都是,先头节点、再左子树、然后右子树

* 中序遍历:任何子树的处理顺序都是,先左子树、再头节点、然后右子树

* 后序遍历:任何子树的处理顺序都是,先左子树、再右子树、然后头节点 

  

结构描述

~~~C#
public class BinaryTreeNode
{
	public int value;
	public BinaryTreeNode left;
	public BinaryTreeNode right; 
}
~~~

**递归序列**
每个节点都会到达三次，如果在第一次遇见节点就输出是先序遍历，如果在第二次遇见节点输出就是中序遍历，如果在第三次遇到节点输出就是后序遍历。

题目一：证明X是二叉树上的某个节点，在这个二叉树的先序遍历序列X左侧的节点和后序遍历的右侧节点的交集都是X的祖先节点。
应为在先序遍历中，头节点先被读取，所以X的祖先节点一定被先读取，后序遍历同理。 而且在先序遍历中X的后代节点都在X的右侧，后序遍历同理。所以这两者的交集只有X的祖先节点。在先序遍历中，X的左侧除了祖先节点之外还有X左树姿态下的右兄和X右树姿态下的左兄。

**非递归方式实现三种遍历**

**先序遍历**

1. 岀栈元素记为curent
2. 将岀栈元素的子节点压入栈，且右侧子节点优先
3. 直到栈弹空

**后续遍历**

1. 岀栈元素记为curent
2. 将岀栈元素的子节点压入栈，且左侧子节点优先
3. 直到栈弹空
4. 倒置序列(入栈后出栈)

**中序遍历**

* 当前遍历节点记为current；curent为根子树的左侧边缘入栈。直到没有左后代。
* 从栈中弹出节点打印，出栈节点的右子节点作为current，重复步骤一
* 直到栈弹空

**实现二叉树的层次遍历**
使用宽度优先遍历 参考LevelTraversalBT
* 将头节点放入
* 从队列里弹出一个节点并打印。
* 如果有左子节点把左孩子入队列，如果有右子节点入队列。(先左后右)
* 重复步骤二和步骤三，直到队列为空
可以通过设置flag变量的方式，来发现某一层的结束。


实现二叉树的序列化和反序列化 参考Serialize
* 先序方式序列化和反序列化
	* 在先序遍历的过程中使用分隔符和空指针符号来填充先序遍历序列。
	* 反序列化时分割各个节点，通过先序遍历的方式构建二叉树。通过空指针符号来重新正确赋值。
* 按层方式序列化和反序列化
	* 与层次遍历类似，需要添加空指针符号。

题目二：现有一颗多叉树，实现其对于二叉树的序列化和反序列化。

思路：使用孩子兄弟表示法来将多叉树转化为二叉树。参考 EncodeNaryTreeToBinarytree

题目三：如何设计一个打印整颗树的函数
* h代表头节点，
* v表示右节点
* ^表示左节点

题目四：求二叉树最宽的层（这层的节点最多）参考 TreeMaxWidth

思路：使用两个额外的变量来完成队列中节点所属层的区分：currentLevelEnd，nextLevelEnd。一开始讲currentLevelEnd设置为已经入队的头节点。从队中出队。出队时先将nextLevelEnd的左节点（如果有）,再将nextLevelEnd设置为右节点。因为头节点已经为本层的最右侧节点，所以本层统计结束。而队列中从头到内存地址与nextLevelEnd相同的节点都属于下一层的节点。在这期间覆盖记录每层节点数的最大值即可。i=currentLevelNumber

题目五：二叉树的节点结构定义如下
~~~C#
public class Node{
	public int value;
	public Node left;
	public Node right;
	public Node parent;
}
~~~
给你二叉树的某个节点，返回该节点的后继节点。参考SuccessorNode

后继节点：中序遍历序列中顺序出现的本节点的下一个节点。

思路：

* 现设x为所在子树的最后测叶子节点。如果x节点有右子树，那么x的后继节点为右子树左下角的左侧节点。

* 现设x为所在子树的最右侧叶子节点。如果x节点没有右子树，那么x的后继节点为父辈节点中第一个作为左侧子节点的父节点b。因为根据中序遍历的规则，只有b节点的左孩子的左子树遍历完成之后，才会去遍历b节点的左孩子的右子树去遍历，只有右子树被遍历完毕，根据中序遍历的规则，b的左节点的左右子树都遍历完成之后才会回到上一个节点（父节点）才能输出。

* 如果找不到第二种情况所描述的节点，那么所给节点就是中序遍历的最后一个节点，并没有后继节点。

  

题目八：请把一段纸条竖着放在桌子上,然后从纸条的下边向上方对折1次,压出折痕后展开。此时折痕是凹下去的,即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次,压出折痕后展开,此时有三条折痕,从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N,代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。例如:N=1时,打印:down N=2时,打印:down down up

参考 PaperFloding

思路：每次折叠时都会再上次折叠出现的折痕的上侧出现凹陷折痕，下侧出现凸起折痕。

* 头节点是凹陷折痕
* 这棵二叉树的高度就是折叠的次数。
* 每次折叠相当于向叶子节点的左侧子节点添加凹陷节点，右侧子节点添加凸起节点。
* 最终的结果为这颗二叉树的中序遍历。
