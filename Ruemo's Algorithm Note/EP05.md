# [归并排序附加题和快速排序](https://www.bilibili.com/video/BV1NovaemE5m)

题目描述：给定一个数组array，两个整数 lower和upper返回array中有多少个子数组的累加和在 lower到upper的范围上。

前缀和数组：指的是每一个元素都是原来数组从0到当前元素相加之和。当需要计算I（其中I小于J）到J之间的累加和时。还需要将前缀和数组的第j元素减去前缀和数组中的第i-1元素即可。

转化解题思路：设前缀数组中下标为17(原数组中前十七个元素的和)中值为100，upper=40、lower=10，设置新的目标为lower'=100-40、upper'=100-10。也就是说，在0到x(0<x<17)的组成的前缀和有落在[60,90]范围内，那么x+1到17这些元素的下标就可以落在[10,40]之间。而获得0到x的组成的前缀和可以在前缀和中直接使用下标找到。这样的话只要讲原始数组中每一个元素作为字数组的末尾，通过上面的转化思路就可以求得下标x到下标y(0<x<y<17)这个范围组成的字数组是否在题意的范围中了。之后进行简单的判断和计数即可。（目的是在合并的过程中求出右侧组中元素，在左侧组中达标的数量）

这个统计的过程是不回退的。

为什么这么计算可以保证使用原数组的数据判断出符合条件的子数组：因为前缀和中的每个元素代表了一个子数组，如果只是单纯的统计有多少符合条件的子数组这么计算没有问题的，但是如果需要输出每个复合条件的子数组的话则需要定义一个结构体，这个结构体有两个部分组成，第一个部分是前缀和，第二个部分是本元素在前缀和数组中的初始下标，这样的话就可以在判断一组子数组符合要求时，根据子数组头部的前缀和到子数组末尾的前缀和的对应下标，打印原始数组这之间的数字即可。这样是可以输出的统计数量和子数组是没有问题的，只是输出没有规律。 

## 快速排序

### 荷兰国旗问题

现在有一个数组，给定一个数x,使得数组中小于等于x的数组放在数组的左侧，大于x的数字在数组的右侧，第二种情况是等于的放在数组的中间，大于x的放在数组的右侧。同时不要求数组有序。返回处理后的数组。要求时间复杂度$O(N)$，空间复杂度$O(1)$。

* 对于小于等于、和大于的情况
  * 为数组设定一个小于等于的区域
  * 如果当前数字小于等于目标数字，把当前数字和小于等于区域的下一个数字交换，然后小于等于区域向右扩充，当前数字的指针指向数组的下一个元素。
  * 如果当前数字大于目标，当前数字的指针指向数组的下一个元素。
  * 重复第二和第三步，直到完成数组的便利。

* 对于小于、等于、大于的情况
  * 为数组设定一个小于区域和一个大于区域
  * 如果当前数字小于目标数字，把当前数字和小于区域的下一个数字交换，然后小于等于区域向右扩充，当前数字的指针指向数组的下一个元素。
  * 如果当前数字等于目标数字，当前数字的指针指向数组的下一个元素。
  * 如果当前数字大于目标数组，当前数字与大于区域的上一个数字交换。大于区域想做扩充。当前数字的指针保持不动。
  * 重复第二到第四步，知道当前数字的下标等于右侧区域的下标。

有了荷兰国旗问题的铺垫之后，快速排序中使用到了相似的技巧，但略有不同。将每次进行荷兰国旗问题的目标数字设定为数字的最后一个元素，完成荷兰国旗问题之后，将数字的最后一个数字与大于区域下标指向的元素进行交换，完成这个数组转化为荷兰国旗问题的结果形式。

### 快速排序1.0

使用数组的最后一个元素作为比较的标准，使用荷兰国旗问题中的**小于等于，大于**的解决方式。保证用于比较的那一个数字在这个数组的中间。完成处理之后，分别对于中间数字的左侧和右侧进行相同的处理，直到被细化的小数组的左右边界下标相等时停止，同时返回等于区域的下标。

### 快速排序2.0

使用数组的最后一个元素作为比较的标准，使用荷兰国旗问题中的**小于、等于、大于**的解决方式。保证与用于比较的一个或多个相等的数字位于数组的中间。完成处理后，分别最中间数字的左侧和右侧进行相同出操作，直到被细化的小数组的左右边界下标相等时停止。同事范围相等区域的下标。

如果在整个数组中包含有重复的元素时，本方法相比上一个方法更快，如果不存在重复的元素，则速度相同。两种方法的在最差的情况下时间复杂度为$O(N^2)$

### 快速排序3.0

在方法二的基础上，通过在排序区域随机选择一个数字并于区域的最后一个元素进行交换，避免每次都能命中特定情况下的最差情况。对于快速排序来说，性能最好的情况时用于划分的数字在排序后用于划分的元素正好落在当前处理范围内的中间。通过随机确定划分数字的方式，选择到排序性能更好和更差的标准数字的概率是相同的。根据master公式可以确定通过随机制定划分元素的方式的时间复杂度为$T(N)=O(N)+2\times T(\frac N 2)\rightarrow O(N \times \log N)$。

### 关于快速排序的额外空间复杂度

如果递归时采用的方式是先向左侧细分，然后向右侧细分，那么细分到最小时并处理完成后就会释放左侧的额外空间（子数组空间），并申请右侧的额外空间（子数组空间），似的整个过程的额外空间复杂度保持在$O(\log N)$。

### 使用迭代的方式实现快速排序

编写一个类，将划分后需要排序的任务放入自定义的栈中，将这个任务的子任务放入栈中，完成任务后从栈中弹出。直到栈被清空。

