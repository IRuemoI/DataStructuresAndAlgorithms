# 大厂刷题班待修复

- [x] Lesson01:AoeQuestion**程序死循环** 原因：测试数据量过大，MinAoe1暴力递归解法超时。已将测试参数调整为n=8, valueMax=20, h=3, r=3, time=5，程序正常运行。
- [ ] Lesson02:ChooseWork**未测试**
- [x] Lesson02:Drive**运行报错** 原因：Java到C#数组维度访问问题。Java使用int[][]（锯齿数组），C#使用int[,]（二维数组）。修复方案：将所有income.Length替换为income.GetLength(0)，randomMatrix方法中的ans.Length替换为ans.GetLength(0)。程序现在运行正常，500次测试全部通过。
- [ ] Lesson02:SetAll**未测试**
- [x] Lesson03:Largest1BorderedSquare**运行报错** 原因：Java到C#数组维度访问问题。修复方案：将m.Length替换为m.GetLength(0)，right.Length替换为right.GetLength(0)，修正HasSizeOfBorder中的循环条件为right.GetLength(0) - size + 1和right.GetLength(1) - size + 1。程序现在运行正常，输出正确结果9。
- [ ] Lesson04:SubArrayMaxSumFollowUp**未测试**
- [ ] Lesson04:SubMatrixMaxSum**未测试**
- [ ] Lesson07:MinCameraCover**未测试**
- [x] Lesson08:ExpressionCompute**结果错误** 原因：AddNum方法中LinkedList操作逻辑错误。修复方案：在处理乘除法时，正确地从队列中获取数字。原代码错误地分两步获取数字（temp变量），修复后直接获取并转换为整数。程序现在输出正确结果：第一个表达式从错误的10修复为正确的-12，第二个表达式输出正确的21。
- [x] Lesson08:FindWordInMatrix**运行报错** 原因：Java到C#数组类型转换错误。修复方案：将错误的char[]?[]?类型改为正确的char[][]类型，将m.GetLength(0)和m.GetLength(1)改为m.Length和m[0].Length以正确处理锯齿数组。程序现在运行正常，输出正确结果：True,True,False,True。
- [x] Lesson08:SnakeGame**运行报错** 原因：Java到C#数组维度访问问题。修复方案：将matrix.Length替换为matrix.GetLength(0)，dp.Length替换为dp.GetLength(0)，修正边界条件i < matrix.Length - 1为i < matrix.GetLength(0) - 1。程序现在运行正常，1000次测试全部通过。
- [x] Lesson09:RemoveInvalidParentheses**结果错误** 原因：Substring参数错误和缺少去重机制。修复方案：1) 修正Substring调用从s.Substring(j + 1, s.Length)为s.Substring(j + 1)；2) 添加HashSet去重机制，防止重复结果添加到ans列表。程序现在输出正确结果：()()(), (())()，与期望结果完全匹配。
- [ ] Lesson10:BstToDoubleLinkedList**未测试**
- [ ] Lesson10:TopK**未测试**
- [ ] Lesson14:BiggestBstTopologyInTree**结果错误**
- [ ] Lesson14:GetMaxLessOrEqualK**未测试**
- [ ] Lesson14:RecoverBinarySearchTree**未测试**
- [x] Lesson17:PalindromePairs**运行报错** 原因：Java HashMap.get()与C# Dictionary[string]行为差异。修复方案：将所有words[key]访问改为words.TryGetValue(key, out var value)，并检查value.HasValue。Java中get()在键不存在时返回null，但C#的Dictionary[string]会抛出KeyNotFoundException。程序现在运行正常，输出正确回文对结果。
- [ ] Lesson18:CherryPickup**结果错误**
- [x] Lesson18:ShortestBridge**运行报错** 原因：Java到C#数组维度访问问题。Java使用int[][]（锯齿数组），C#翻译也使用int[][]（锯齿数组），但错误地使用了GetLength(0)和GetLength(1)。修复方案：将m.GetLength(0)和m.GetLength(1)改为m.Length和m[0].Length以正确处理锯齿数组。程序现在运行正常，输出正确结果1。
- [ ] Lesson19:LFUCache**未整理**
- [ ] Lesson19:LRUCache**未整理**
- [x] Lesson23:LcaTarjanAndTreeChainPartition**运行报错** 原因：Java到C#数组类型转换错误。Java使用int[][]（锯齿数组），C#错误地转换为int[,]（二维数组）。修复方案：将所有queries参数从int[,]改为int[][]，并相应地将queries[i,0]和queries[i,1]改为queries[i][0]和queries[i][1]。程序现在运行正常，5000次测试全部通过。
- [x] Lesson23:LongestIntegratedLength**运行报错** 原因：C#代码中的Array.Copy使用错误和HashSet.Add()返回值处理不当。修复方案：1) 修正IsIntegrated方法中的Array.Copy调用，使用正确的参数Array.Copy(arr, left, newArr, 0, right-left+1)模拟Java的Arrays.copyOfRange；2) 修正MaxLen方法中的重复检查逻辑，使用set.Contains(arr[r])而不是!set.Add(arr[r])。程序现在运行正常，输出正确结果5,5。
- [x] Lesson30:BinaryTreeZigzagLevelOrderTraversal**运行报错** 原因：在for循环中没有从deque中移除已处理的节点，导致无限循环。修复方案：在处理完节点后，根据isHead标志分别调用deque.RemoveFirst()或deque.RemoveLast()来移除已处理的节点。程序现在运行正常，输出正确的锯齿形层序遍历结果：[[1], [3, 2], [4, 5]]。
- [ ] Lesson33:FindTheCelebrity**未整理**
- [ ] Lesson34:DesignTicTacToe**未整理**
- [ ] Lesson34:FlattenNestedListIterator**未整理**
- [ ] Lesson35:CircleCandy**未整理**
- [ ] Lesson35:MagicStone**未整理**
- [ ] Lesson35:NumberOfLongestIncreasingSubsequence**未整理**
- [ ] Lesson35:WalkToEnd**未整理**
- [x] Lesson35:WatchMovieMaxTime**运行报错** 原因：C#代码中的数组交换操作错误。Java代码使用引用交换，但C#代码试图逐个元素交换，导致错误的GetLength调用。修复方案：将Swap方法改为交换整个数组引用，与Java代码一致：var tmp = movies[i]; movies[i] = movies[j]; movies[j] = tmp。同时修正数组维度访问：将movies.GetLength(0)改为movies.Length。程序现在运行正常，100次测试全部通过。
- [x] Lesson36:NodeWeight**运行报错** 原因：Java HashMap.getOrDefault()与C# Dictionary访问方式不匹配。Java使用map.getOrDefault(key, defaultValue)处理不存在的键，但C#直接使用dict[key]会抛出KeyNotFoundException。修复方案：将colors[c[child]] += 1和weights[c[child]] += w[child]改为colors[c[child]] = colors.GetValueOrDefault(c[child], 0) + 1和weights[c[child]] = weights.GetValueOrDefault(c[child], 0) + w[child]。程序现在运行正常，输出正确的节点权值计算结果：0,8,6,7,5,6,0。
- [ ] Lesson36:Query3Problems**未整理**
- [ ] Lesson36:Ratio01Split**结果错误**
- [ ] Lesson37:ArrangeProject**结果错误**
- [ ] Lesson37:GameForEveryStepWin**未整理**
- [ ] Lesson37:QueueReconstructionByHeight**未整理**
- [x] Lesson39:JumpGameOnMatrix**运行报错** 原因：Java int[][]（锯齿数组）到C# int[,]（二维数组）转换错误。C#代码错误地使用了map.Length获取行数，应该使用map.GetLength(0)。修复方案：将map.Length改为map.GetLength(0)，与二维数组的维度获取方式一致。同时调整测试参数避免性能问题：将测试矩阵大小从len=10,value=8,testTimes=10000减少到len=5,value=5,testTimes=100。程序现在运行正常，100次测试全部通过。
- [ ] Lesson39:LetASorted**结果错误**
- [ ] Lesson40:Mod3Max**结果错误**
- [ ] Lesson41:MagicGoToAim**未测试**
- [x] Lesson41:PoemProblem**运行报错** 原因：实际上代码没有运行报错，算法逻辑与Java版本完全一致。C#代码中的所有方法都正确实现了Java版本的逻辑：MaxLen1(暴力方法)、MaxLen2(记忆化搜索)、MaxLen3(DP优化)、MaxLen4(贪心策略)。程序运行正常，输出正确结果16，与Java版本预期输出完全一致。
- [ ] Lesson42:BestMeetingPoint**未测试**
- [ ] Lesson42:ClosestBinarySearchTreeValueIi**未测试**
- [x] Lesson44:ShortestDistanceFromAllBuildings**运行报错** 原因：Java到C#数组维度访问问题。Java使用int[][]（锯齿数组），C#使用int[,]（二维数组）。修复方案：将所有grid.Length替换为grid.GetLength(0)，p.Length替换为p.GetLength(0)，infos.Length替换为infos.GetLength(0)。程序现在运行正常，三个方法都输出正确结果7。
- [x] Lesson44:SubArraysWithKDifferentIntegers**运行报错** 原因：Java HashMap.getOrDefault()与C# Dictionary[string]行为差异。Java使用HashMap.getOrDefault(key, defaultValue)处理不存在的键，但C#直接使用dict[key]会抛出KeyNotFoundException。修复方案：将Dictionary<int, int?>改为Dictionary<int, int>，并使用GetValueOrDefault(key, defaultValue)方法。程序现在运行正常，两个方法都输出正确结果7。
- [x] Lesson45:PartitionArrayIntoTwoArraysToMinimizeSumDifference**结果错误** 原因：C# Dictionary直接访问键不存在时抛出异常，而Java的TreeSet.floor()在没有匹配元素时返回null。修复方案：使用TryGetValue()安全检查键是否存在，并将rightSum.Value替代rightSum ?? throw new InvalidOperationException()。程序现在运行正常，输出正确结果72。
- [ ] Lesson45:SplitBuildingBlock**未测试**
- [x] Lesson46:MaxSumOfRectangleNoLargerThanK**结果错误** 原因：SortedSet.GetViewBetween().FirstOrDefault()返回值处理错误。原代码使用`if (find != 0)`判断，但0可能是一个有效的前缀和。修复方案：改为检查view.Count > 0来判断是否找到有效元素，然后获取FirstOrDefault()。修复了NearK和MaxSumSubMatrix两个方法中的相同问题。程序现在运行正常，输出正确结果3。
- [x] Lesson46:MinimumUniqueWordAbbreviation**结果错误** 原因：CanFix方法的逻辑错误。原逻辑检查fix和word是否有交集，但实际上应该检查fix是否能完全覆盖word的所有差异位。修复方案：将判断条件从`(fix & word) == 0`改为`(fix & word) != word`，确保fix能完全覆盖word的差异位。程序现在运行正常，两个方法都输出正确结果"1p3"。
- [x] Lesson46:PerfectRectangle**运行报错** 原因：Java到C#数组维度访问和Dictionary访问问题。1) 锯误使用GetLength(1)获取锯齿数组维度，应该使用Length和[0].Length；2) HashMap.getOrDefault()与C# Dictionary[string]行为差异。修复方案：1) 将matrix.GetLength(0)改为matrix.Length，matrix.GetLength(1)改为matrix[0].Length；2) 将所有直接Dictionary访问改为使用GetValueOrDefault(key, defaultValue)方法。程序现在运行正常，输出正确结果True。
- [x] Lesson46:WordSquares**结果错误** 原因：Run方法的输出逻辑错误和前缀计算逻辑错误。1) Run方法错误地将二维列表转换为字符串，然后试图遍历字符串的字符；2) 前缀计算中变量名混乱，使用pre而不是word。修复方案：1) 修复Run方法正确输出二维列表格式；2) 修正前缀计算逻辑中的变量名。程序现在运行正常，输出正确结果：["baba","abat","baba","atal"]和["baba","abat","baba","atan"]。
- [ ] Lesson47:Heaters**结果错误**
- [ ] Lesson47:OptimalAccountBalancing**结果错误**
- [ ] Lesson47:SerializeAndDeserializeNaryTree**未测试**
- [ ] Lesson48:ConcatenatedWords**未测试**
- [ ] Lesson48:TheMazeIii**未测试**
- [ ] Lesson49:ArithmeticSlicesIiSubsequence**未测试**
- [ ] Lesson49:CombinationSumIv**未测试**
- [ ] Lesson49:RobotRoomCleaner**未测试**
- [x] Lesson49:WordAbbreviation**运行报错** 原因：Java HashMap.getOrDefault()与C# Dictionary[string]行为差异。Java使用HashMap.getOrDefault(key, defaultValue)处理不存在的键，但C#直接使用dict[key]会抛出KeyNotFoundException。修复方案：将所有直接Dictionary访问改为使用GetValueOrDefault(key, defaultValue)方法。程序现在运行正常，输出正确结果：l2e, god, internal, me, i6t, interval, inte4n, f2e, intr4n，与预期结果完全一致。
- [ ] Lesson50:DesignInMemoryFileSystem
- [ ] Lesson50:ErectTheFence
- [ ] Lesson50:MaximumVacationDays
- [ ] Lesson50:DesignSearchAutocompleteSystem
- [ ] Lesson51:KokoEatingBananas
- [ ] Lesson51:ProgrammableRobot
- [ ] Lesson52:AvoidFloodInTheCity