# [从暴力递归到动态规划4](https://www.bilibili.com/video/BV1tDvaeQEBx)

## 数组压缩技巧

矩阵中的最小路径和

问题：给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。

```csharp
private static int MinPathSum2(int[,]? m)
{
    if (m == null || m.GetLength(0) == 0 || m[0, 0] == 0) return 0;

    var row = m.GetLength(0);
    var col = m.GetLength(1);
    var dp = new int[col];
    dp[0] = m[0, 0];
    for (var j = 1; j < col; j++) dp[j] = dp[j - 1] + m[0, j];

    for (var i = 1; i < row; i++)
    {
        dp[0] += m[i, 0];
        for (var j = 1; j < col; j++) dp[j] = Math.Min(dp[j - 1], dp[j]) + m[i, j];
    }

    return dp[col - 1];
}
```
**数组压缩技巧**

1. 表中每个依赖它的左侧和上方的元素，可以只使用一行或者一列(较短的那一边)的数组完成填表过程。同时优化空间使用
2. 表中每个依赖它的左侧和左上上元素，这种情况下，第一行是可以通过base case直接得到的，所以剩下的每行，从右向左填充即可
3. 如果依赖左侧、上方以及左上方的元素，可以使用一个额外的变量保存**原来的左上的值**来完成填表

## 货币面值系列问题

### 题目一:货币数组组成面值的方法数-同值认为不同    请注意对比题目一

题目:arr是货币数组，其中的值都是正数。给定一个正数aim。每个值都认为是一张货币，即便值相同也认为是两张不同的货币。返回组成aim的方法数。例如：arr={1,1,1}，aim=2。第0个和第1个能组成2;第0个和第2个能组成2;第1个和第2个能组成2;一共三种方法。

思路:从左往右的尝试模型。解释：要或者不要的零一背包问题。参考:CoinsWayEveryPaperDifferent.cs

### 题目二:面值数组组成面值的方法数-张数不限
题目:arr是面值数组，其中的值都是正数且没有重复。给定一个正数aim。每个值都认为是一种面值，且认为张数是无线的。返回组成aim的方法数。例如：arr={1,2}，aim=4。1+1+1+1;1+1+2;2+2;一共三种方法。

思路:从左往右的尝试模型。解释:每个步骤选择0到(aim/当前面值)这几种尝试中选择一种，类似零一背包模型，但是每次的可选范围从是或否变成了0到使用多张单一货币组成目标面值。参考:CoinsWayNoLimit.cs**通过观察得出表中普遍元素的严格依赖关系化简了一个迭代操作**

### 题目三:货币数组组成面值的方法数-同值无差别(张数限定)     请注意对比题目三

题目:arr是货币数组，其中的值都是正数。给定一个正数aim。每个值都认为是一张货币。认为值相同的货币没有任何不同。返回组成aim的方法数。例如：arr={1,2,1,1,2,1,2}，aim=4。1+1+1+1;1+1+2;2+2;一共三种方法。

思路:还是从左到右的尝试模型。首先先建立一个每个面值为key张数为value的剩余可用货币的字典。在上一题的判读条件基础上添加不超过可用的货币张数。那么在张数不够时，他的依赖关系就和上一题不同了。参考：CoinsWaysSameValueSamePaper.cs

### 题目四: Bob生还的概率

题目：给定五个参数:N,M,row,col,k。表示在NxM的区域上，醉汉Bob初始在[row,col]位置，Bob一共要迈出k步，且每步都会等概率的向上下左右四个方向走一个单位，任何时候Bob只要离开NxM的区域，就会死亡。返回k步之后。Bob还在NxM区域的概率

思路：参考之前的象棋跳马问题
