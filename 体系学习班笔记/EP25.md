# [单调栈](https://www.bilibili.com/video/BV1TXvaenE4X)

单调栈实现目的：对于一个整型数组，找出每个元素左右两侧第一个比本身小的元素的下标存储在栈中，同时时间复杂度$O(N)$。

```csharp
//重点是在入栈时弹出比当前元素大的栈顶元素，直到栈内元素具有单调性。因为即将入栈而被弹出的元素的右侧比他小的元素就是当前入栈元素
private static int[,] GetNearLess(int[] arr)
{
    // 初始化结果数组：[N,0]存左侧最近更小索引，[N,1]存右侧最近更小索引 
    var res = new int[arr.Length, 2];
    // 单调栈：栈中元素是按值升序排列的索引列表，列表用于处理重复值 
    Stack<List<int>> stack = new();

    // 正向遍历数组元素 
    for (var i = 0; i < arr.Length; i++)
    {
        // 维护单调性：弹出所有比当前元素大的栈顶元素 
        while (stack.Count != 0 && arr[stack.Peek()[0]] > arr[i])
        {
            var popIs = stack.Pop(); // 获取待处理的索引列表 
            // 计算左侧最近更小值索引：栈空则为-1，否则取新栈顶最后一个元素 
            var leftLessIndex = stack.Count == 0 ? -1 : stack.Peek()[^1]; 

            // 为弹出的所有索引设置结果 
            foreach (var popI in popIs)
            {
                res[popI, 0] = leftLessIndex; // 左侧更小索引 
                res[popI, 1] = i;            // 右侧更小索引即当前索引i 
            }
        }

        // 处理相等值：将当前索引加入已有列表，维持相同值的索引连续存储 
        if (stack.Count != 0 && arr[stack.Peek()[0]] == arr[i])
        {
            stack.Peek().Add(i);
        }
        // 处理新较小值：创建新列表压入栈 
        else 
        {
            List<int> list = [i]; // C# 12集合表达式初始化 
            stack.Push(list);
        }
    }

    // 处理栈中剩余元素（右侧无更小值的情况）
    while (stack.Count != 0)
    {
        var popIs = stack.Pop();
        // 左侧更小索引处理逻辑与循环中相同 
        var leftLessIndex = stack.Count == 0 ? -1 : stack.Peek()[^1];
        foreach (var popI in popIs)
        {
            res[popI, 0] = leftLessIndex;
            res[popI, 1] = -1; // 右侧无更小值设为-1 
        }
    }

    return res;
}
```

