# [二叉树的基本算法及其递归套路](https://www.bilibili.com/video/BV1sFvYe1EwD)
## 二叉树(续)

### 题目一：判断二叉树是否是完全二叉树，如何用递归套路解题。
思路：根据子树的最后一个(最下层最右侧)的位置来进行分类 查看isBCT.isBCT2

* 左子树是满二叉树，右子树是二叉树，左子树高度等于右子树高度。整个子树是满二叉树。
* 如果最下层最右侧的节点未超过中线的一半。保证左子树是完全二叉树，右子树是满二叉树，且高度与左子树相差一
* 如果最下层左右侧的及诶单正好在中线上，保证左子树是满二叉树，柚子树是满二叉树，且高度与左子树相差一
* 如果最下层次最右侧的节点数超过了中线保证左子树是满二叉树，右子树是完全二叉树。左子树的高度等于右子树高度 

### 题目二：返回给定二叉树中的最大二叉搜索树的头节点

参考maxSubCBT

### 题目三：给定一个二叉树和其中包含的两个节点a,b。返回这两个节点的最低公共祖先
**最低公共祖先**：两个节点相交的第一个是节点

思路：设开始时AB两个为空；返回当前节点所在子树是否包含A；返回当前节点所在子树是否包含B；如果A,B两个节点都找到了，停止遍历，返回当前子树的根节点

* 与当前子树根节点无关
	* 若AB已经在当前子树的左子树中汇聚
	* 若AB已经在当前子树的右子树中汇聚
	* 当前子树不是全部包含AB两个节点
* 与当前子树根节点有关
	* 左子树发现A或B，右子树发现另一个
	* 当前节点是A或B，在左右子树中发现了另一个
* 否则没有答案
### 题目四：
公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级.

这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：

1. 如果某个员工来了，那么这个员工的所有直接下级都不能来
2. 派对的整体快乐值是所有到场员工快乐值的累加
3. 你的目标是让派对的整体快乐值尽量大

给定一棵多叉树的头节点boss，请返回派对的最大快乐值

思路：参考maxHappy.maxHappy2

* 以当前节点所在子树
	* 在当前节点参加的情况下
		* 下一级子节点一定参加
	* 在当前节点不参加的情况下
		* 下一级节点或者参加或者不参加
	* 返回以上两种情况中较大的

## 贪心部分
贪心算法
1. 最自然智慧的算法
2. 用一种局部最功利的标准，总是做出在当前看起来最好的选择
3. 难点在于证明局部最功利的标准可以得到全局最优解
4. 对于贪心算法的学习主要以增加阅历和经验为主

### 题目五：给定一个由字符串组成的数字strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果
字典序：两个长度不相等的字符串通过将较短的字符串向右补空的方式按照字母顺序进行比较

思路：如果字符串A拼接字符串B的字典序小于字符串B拼接字符串A，那么将字符串A放在字符串B的前面

证明：

1. 证明排序策略是有传递性。比如在本题中需要证明因：由于a.append(B)<=b.append(a)且b.append(c)<=c.append(b)可以推导出a.append(c)<=c.append(a)
2. 将字符串拼接过程转化为数值计算过程$a\times k^{b.Length}+b$；令函数m=$k^{b.Length}$，重新表达两条推理条件。条件一两边同时减去b乘以c得到$a\times m(b)\times c\le c \times b\times m(a)+a\times c-b\times c$；条件二两边同时减去b乘以得到$a\times b\times m(c)+c\times a-b\times a\le c\times m(b)\times a$;从而推出$a\times b\times m(c)+a\times  c-b\times a\le c\times b\times m(a)+a\times c-b\times c$，化简得出$a\times m(c)+c\le c\times m(a)+a$。证毕。
3. 证明拼接按照以上方法拼接的字典序最小的原因：证明拼接后的序列中交换前后任意两个元素之后字典序只增不减。设待交换的两元素ab中间有n个元素(n≥0)。经过两趟交换：第一趟，每次将a与下一个元素进行交换，直到与b交换完成。在这过程中的每一步交换字典序都是只增不减的。第二趟，每次将b与上一个元素进行交换，直到b被交换到a原来的位置，在这一过程中的每一步交换字典序都是只增不减的。至此完成ab量元素在拼接序列中的交换。所以拼接序列中任意两个元素交换对字典序的影响都是只增不减的。
以上过程是证明通过贪心算法得出的局部最优解是全局最优解的过程。过程复杂，**所以一半在解决贪心问题时，不会通过数学证明来判断贪心结果的正确性**。实践中，通过在对数器使用暴力法作为比较依据对比已经提出的多种策略从而得出正确的最优的贪心算法。贪心算法在面试时一般不会考：无法体现出代码能力；无法体现出逻辑能力水平，只有通过和不通过。
