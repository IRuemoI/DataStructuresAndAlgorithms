# [窗口内最大值或最小值的更新结构](https://www.bilibili.com/video/BV1T9vaeSEHH)

## 滑动窗口是什么?

滑动窗口是一种想象出来的数据结构：

滑动窗口有左边界L和有边界R

在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分

L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口

L和R都只能往右滑

## 使用双向链表/双端队列获取窗口内最大值的原理

首先我们有一个若干长度的整型数组和一个滑动窗口，并准备一个双向链表。我们约定将新的元素加入链表或队列的同时需要添加这个元素在原始数组中的下标。

我们考虑两种情况：

* 当窗口的右边界向右移动时：
  * 如果新的从尾部加入链表的元素不会破坏链表中的元素是从大到小排列的，那么这个元素可以从尾部加入链表
  * 如果新的从尾部添加的元素破坏了从大到小的排列，那么将链表尾部的一个或者多个元素丢弃，直到链表最后一个元素大于当前需要添加到链表的元素后将新的元素添加到链表的尾部。此时链表仍然保持从大到小的排列。
  * 如果新添加的元素与链表尾部的元素**重复**，那么尾部的元素被新的元素替换
* 当窗口的左边界向右移动时
  * 如果在链表中记录的首个元素没有过期——当前窗口左边界指向的元素的下标小于等于链表中首个元素的下标。那么链表的首个元素保留。如果过期，丢弃链表中的首个元素。

当我们每次获取队列头部元素的值时就是滑动窗口内所有元素的最大值。同时处理完整个数组它的时间复杂度时O(n)，获取最大值的时间复杂度是O(1)

注意：在实际的应用中，双端链表中只放下标，只用这个下标从原始数组中获取下标对应的值。

### 问题一：滑动窗口内求最大值

```csharp
private static int[]? GetMaxWindow(int[]? arr, int w)
{
    if (arr == null || w < 1 || arr.Length < w) return null;
    LinkedList<int> queueMax = new();
    var result = new int[arr.Length - w + 1];
    var index = 0;
    for (var r = 0; r < arr.Length; r++)
    {
        //如果新的要添加到双向链表的新元素大于链表下标代表的原始值。那么将这些值对应的下标以从尾部移除方式进行移除
        while (queueMax.Count != 0 && arr[queueMax.Last()] <= arr[r]) queueMax.RemoveLast();
        //将新元素的下标添加到双向链表尾部
        queueMax.AddLast(r);
        //如果双向链表头部下标对应的元素已经过期，移除过期的所引
        if (queueMax.First() == r - w) queueMax.RemoveFirst();
        //只有在窗口的大小达到规定的大小时才会收集答案
        if (r >= w - 1) result[index++] = arr[queueMax.First()];
    }

    return result;
}
```

### 问题二： 整型数组中子数组最大值减最小值达标的子数组个数

题目：给定一个整型数组arr，和一个整数num。某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，返回arr中达标子数组的数量

思路：

1. 如果某个子数组达标，那么它包含在子数组也达标——对于更小的子数组来说，能够包含它的更大子数组的上下限(最大值和最小值)只会更宽
2. 如果一个数组不达标，窗口向左扩张或者向后扩张组成的新的子数组也不达标
3. 同时使用两个双向链表维持窗内的最大值和最小值
4. 每次先让有边界向后扩张，直到子数组不达标，那么从左边界到右边界内所有子数都都是达标的，将记录本次子数组的数量（rightEdge-leftEdge个）记录到最终结果，然后向右移动一次窗口的左边界。继续下一轮的记录

代码：AllLessNumSubArray

### 问题三：加油站的良好出发点问题

题目：N个加油站组成一个环形，给定两个长度都是N的非负数组 oil和dis(N>1)，oil[i]代表 第i个加油站存的油可以跑多少千米，dis[i]代表第i个加油站到环中下一个加油站相隔 多少千米。 假设你有一辆油箱足够大的车，初始时车里没有油。如果车从第i个加油站出发，最终 可以回到这个加油站，那么第i个加油站就算良好出发点，否则就不算。 请返回长度为N的boolean型数组res，res[i]代表第 i 个加油站是不是良好出发点。

思路：

1. 每个oil数组中的元素与dis数组中的元素相减，得到经过加油站后的剩余油量。所以现在的问题转化为如果加上下一站的剩余油量为负数，那么这个方案不可行。
2. 用两个这样的新数组并排，依次用当前数加上上一个数组成一个两倍长的表示所有起点出发情况的油量剩余参考数组
3. 比如我们从第二个加油站出发，只需要从油量剩余参考数组从取出从第二个加油站出发的数组中下标从1到N个元素组成的新数组每个元素减去参考数组中下标为0的值即可获得从当前起起点经过之后的加油站的剩余油量了
4. 准备一个长度为n的在油量剩余参考数组上滑动的滑动窗口，如果滑动窗口的最小值小于0那么这个滑动窗口表示的方案不可行
5. 向右滑动窗口，直到将所有加油站都为起点的方案都验证一遍

代码：GasStation

关于使用滑动窗口解体的小总结：求解过程需要从滑动窗口的过程中直接获取或者计算得出，并且这个过程窗口是不回退的

### 问题四: 货币数组组成面值的最少货币数(动态规划) @02:00:00

题目：arr是货币数组，其中的值都是正数。再给定一个正数aim。每个值都认为是一张货币，返回组成aim的最少货币数。需要注意的是，因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了

思路：

代码：

## 课后总结

货币数组组成面值的最少货币数-难点解释]