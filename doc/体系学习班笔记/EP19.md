# [从暴力递归到动态规划2](https://www.bilibili.com/video/BV1PfvaejEu4)

几种暴力递的尝试模型

* 从左往右的尝试模型
* 范围上尝试的模型

### 题目一：背包能装下最多的价值

题目：给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少? 

思路：需要注意的是可能出现单个物品的重量大于背包的容量，此时是一种无效的情况，我们返回-1。表的每行表示拿第i号物品，列表示背包还剩下多少容量。行的范围是0到N,列范围是0到bag+1(无效情况我们在函数中已经处理)。表中每个常规元素(除最后一行)都依赖它下方的元素

### 题目二：数字转化为字符串的结果数

题目：规定A-Z分别对应1-26.那么一个数字字符串比如"111”就可以转化为:"AAA"、"KA"和"AK"。给定一个只有数字字符组成的字符串str，返回有多少种转化结果 

思路：不要让数字0或者超过26的数字进行转换，是无效的

### 题目三：多少张贴纸可以贴出给定字符串|贴纸拼词

题目：给定一个字符串str，给定一个字符串类型的数组arr。arr里的每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来。返回需要至少多少张贴纸可以完成这个任务。

例子：str= "babac"，arr = {"ba","c","abcd"}至少需要两张贴纸"ba"和"abcd"，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2

思路：

1. 尝试暴力递归：每次对于贴纸数组中的其中一张，尝试多次
2. 边界条件的处理：如果不可能拼出单词，用整型最大值表示
3. 剪枝：只尝试剩余目标字符串中首字母的字母贴纸
4. 可变参数(字符串)的范围不能确定，所以无法改写成dp表的形式，只能记忆化搜索(直接拿之前算过的结果)

### 题目四：最长公共子序列

题目：给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

思路：样本对应模型——两个样本作为两个输入参数，通过查找更小的样本得到的结果来加速本次输入样本的结果(查表)。一个样本做行，一个样本做列的对应模型。考虑三种情况：

1. 用更小的第一个样本和当前的第二个样本来计算并填充表格dp[i-1,j]位置的数据
2. 用更小的第二个样本和当前的第一个样本来计算并填充表格dp[i,j-1]位置的数据
3. 当两个样本最后一个元素相等，用更小的第一个样本和用更小的第二个样本来计算并填充表格dp[i-1,j-1]位置的数据

当然其他的情况也是有的，我们具体情况具体处理即可。详情查看LongestCommonSubsequence

