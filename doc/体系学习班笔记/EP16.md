## [图部分](https://www.bilibili.com/video/BV1sfvaejEyr)

**图基础**

* 有向图与无向图

* 邻接表和邻接矩阵

* 理解代码中给出的点、边、图定义

**宽度优先遍历**

在二叉树的层次遍历的基础上添加一个集合保存已经遍历过的节点。

**深度优先遍历**

一条路走到黑，然后返回到没有这个遍历中的序列中的节点旁边未遍历的节点。直到图遍历完成。需要使用栈和集合。

**拓扑排序**

前提：有向无环图

比如在编译时需要先将依赖编译完成后才能进行编译。拓扑排序的结果就是给出一个正确的处理顺序。且正确的结果一般不唯一

1. 在图中找到所有入度为0的点输出

2. 把所有入度为0的点在图中删掉,继续找入度为0的点输出,周而复始

3. 图的所有点都被删除后,依次输出的顺序就是拓扑排序

要求:有向图且其中没有环

应用:事件安排、编译顺序

orderdfs2点次排序orderdfs1最大深度排序

**克鲁斯卡尔算法**

每次选择权值最小的节点合并到现有集合，知道所有点被合并到集合

前提：无向有权图

1. 总是从权值最小的边开始考虑,依次考察权值依次变大的边
2. 当前的边要么进入最小生成树的集合,要么丢弃
3. 如果当前的边进入最小生成树的集合中不会形成环,就要当前边
4. 如果当前的边进入最小生成树的集合中会形成环,就不要当前边
5. 考察完所有边之后,最小生成树的集合也得到了
   使用并查集，解决最小生成树。

**普里姆算法**

从图中的某一点出发，每次选择下一个不会形成环的权值最小的边。解锁下一篇相邻的边。

1. 可以从任意节点出发来寻找最小生成树
2. 某个点加入到被选取的点中后,解锁这个点出发的所有新的边
3. 在所有解锁的边中选最小的边,然后看看这个边会不会形成环
4. 如果会,不要当前边,继续考察剩下解锁的边中最小的边,重复步骤3
5. 如果不会,要当前边,将该边的指向点加入到被选取的点中,重复步骤2
6. 当所有点都被选取,最小生成树就得到了

**迪杰斯特拉算法**

通过不断利用之间已经得出的距离加上下一个节点来替换最小距离，从而的得出起点与其他各个点的距离

1. Dijkstra算法必须指定一个源点   

2. 生成一个源点到各个点的最小距离数组，第一个元素被填充，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大  

3. 从距离表中拿出没有被访问数组中里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步  

4. 源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了  

普通堆实现的Dijkstra算法，时间复杂度O(m*log m)，m为边数

```csharp
1，distance[i]表示从源点到i点的最短距离，visited[i]表示i节点是否从小根堆弹出过
2，准备好小根堆，小根堆存放记录：（x点，源点到x的距离），小根堆根据距离组织
3，令distance[源点]=0，(源点，0)进入小根堆
4，从小根堆弹出(u点，源点到u的距离)
    a.如果visited[u]==true，不做任何处理，重复步骤4
    b.如果visited[u]== false,令visited[u]=true,u就算弹出过了然后考察u的每一条边，假设某边去往v，边权为w
        1) 如果visited[v]== false 并且 distance[u] + w < distance[v]令distance[v]= distance[u]+ w,把(v,distance[u] + w)加入小根堆
        2）处理完u的每一条边之后，重复步骤4
5，小根堆为空过程结束，distance表记录了源点到每个节点的最短距离
```

**使用加强堆优化迪杰斯特拉**(第17节)



参考方法：

**A\*算法** [链接](https://www.bilibili.com/video/BV1t94y187zW)

A*算法在迪杰斯特拉算法上引入了启发式函数，在小根堆的排序中将目前从原点到此处的距离与当前与目标的距离之和作为排序的依据，那么就会优先选择**到达当前位置目标和与目标距离最短的节点**，从可视化效果上有由目标点产生的一种吸引效果。

曼哈顿距离：直角三角形的两条直角边长度之和。