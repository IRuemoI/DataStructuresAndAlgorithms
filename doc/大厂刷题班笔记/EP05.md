## 二叉树重建题目 
### 题目描述
给定一棵搜索二叉树的先序遍历结果，要求根据该结果重建整棵树，并返回头节点。

### 解题思路
- 定义一个递归函数f，输入数组范围从l到r，输出该范围对应的子树头节点。
- 主函数调用f(0, n-1)，其中n为数组长度。
- 在递归函数中：
  * 如果l > r，返回空节点。
  * 否则，取数组第l个元素作为当前子树的头节点。
  * 找到第一个大于头节点值的位置first_big。
  * 递归构建左子树f(l+1, first_big-1)和右子树f(first_big, r)。
  * 将左右子树连接到当前头节点上并返回。

相等子树数量题目
### 题目描述
给定一棵二叉树，定义相等子树为左右子树结构完全相同的子树，求整棵树中有多少棵相等子树。

### 解题思路 
- 使用递归方法解决，定义两个递归函数f和g。
- 函数f用于验证两棵树是否相等，采用深度优先搜索的方式比较节点值及左右子树。
- 函数g用于计算以某个节点为根的树有多少棵相等子树，通过递归调用自身分别获取左右子树的相等子树数量a和b。
- 如果左右子树相等，则当前树也为相等子树，返回a+b+1；否则返回a+b。
- 利用哈希函数优化左右子树比对过程，将比对复杂度从O(n)降为O(1)。

编辑距离题目
### 题目描述
给定两个字符串string1和string2，以及删除、插入、替换操作的成本d、a、r，求将string1编辑成string2所需的最低成本。

### 解题思路
- 使用动态规划解决，定义dp[i][j]为将string1前i个字符编辑成string2前j个字符所需的最低成本。
- 初始化边界条件：dp[0][j]=j*a，dp[i][0]=i*d。
- 对于普通位置(i,j)，考虑四种可能性：
  * 从dp[i-1][j]删除最后一个字符，成本+d。
  * 从dp[i][j-1]插入最后一个字符，成本+a。
  * 如果string1[i]==string2[j]，从dp[i-1][j-1]保留最后一个字符，成本+0。
  * 如果string1[i]!=string2[j]，从dp[i-1][j-1]替换最后一个字符，成本+r。
- dp[i][j]取上述四种可能性中的最小值。
- 最终答案为dp[n][m]，其中n和m分别为string1和string2的长度。

注意事项
- 加入算法QQ群时，注意一群已满，可加入二群（群号：1031295201）。
- 观看课程直播前，建议先学习体系班内容，尤其是二叉树递归套路、单调栈、动态规划等基础知识。
- 复习本节课内容时，重点掌握二叉树递归套路、哈希函数的应用、动态规划的建模与实现。
- 实践过程中，尝试自己编写代码实现上述解法，并使用不同测试用例验证其正确性。