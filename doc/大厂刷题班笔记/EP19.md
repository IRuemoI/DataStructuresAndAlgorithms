## 1 LRU缓存机制

### 题目

实现一个LRU缓存，支持`get`和`put`操作，并且时间复杂度为O(1)。

### 思路

- **数据结构选择**：使用哈希表（HashMap）和双向链表来实现。哈希表用于快速查找节点，双向链表用于维护节点的访问顺序。

- **构造方法**：初始化时指定缓存容量，创建空的哈希表和双向链表。

- get操作

  ：

  - 如果key存在，返回对应的value，并将该节点移到链表尾部（表示最近访问）。
  - 如果key不存在，返回-1。

- put操作

  ：

  - 如果key已存在，更新其value，并将该节点移到链表尾部。
  - 如果key不存在，创建新节点并插入到链表尾部。如果插入后超出容量，则删除链表头部的节点（最久未访问的节点）。

- **节点移动**：通过调整节点的前后指针实现节点在链表中的移动。

## 2 LFU缓存机制

### 题目

实现一个LFU缓存，支持`get`和`put`操作，并且时间复杂度为O(1)。

### 思路

- **数据结构选择**：使用两个哈希表，一个用于存储key到节点的映射，另一个用于存储节点到频率桶的映射。频率桶内部使用双向链表来维护节点顺序。

- **构造方法**：初始化时指定缓存容量，创建空的哈希表和频率桶。

- get操作

  ：

  - 如果key存在，返回对应的value，并将该节点从当前频率桶中移除，然后插入到频率+1的桶中。
  - 如果key不存在，返回-1。

- put操作

  ：

  - 如果key已存在，更新其value，并将该节点从当前频率桶中移除，然后插入到频率+1的桶中。
  - 如果key不存在，创建新节点并插入到频率为1的桶中。如果插入后超出容量，则删除最低频率桶中的最后一个节点。

- **频率桶管理**：当某个频率桶为空时，需要将其从频率桶列表中删除。

## 3 数位统计问题

### 题目

给定一个整数n，统计从1到n的所有数字中包含多少个数字1。

### 思路

- **递归分治**：将问题分解为更小的子问题进行求解。

- **按位分析**：对于给定的数字，逐位分析每一位上可能出现的1的数量。

- 具体步骤

  ：

  - 将数字分为最高位和其他位两部分。
  - 计算最高位上的1的数量。
  - 递归计算剩余位上的1的数量。
  - 最终结果为最高位上的1数量加上剩余位上的1数量。

- **特殊情况处理**：当最高位为1时，需要特别处理，因为此时最高位上的1数量与剩余部分的值有关。

### 注意事项

- 在大厂面试中，数位DP问题出现较少，但此题属于高频题目，需掌握。
- 数位DP和轮廓线DP等概念较难，但在大厂面试中很少出现，可根据自身情况选择性学习。
- 实现代码时要注意边界条件和特殊情况的处理，确保算法的正确性和鲁棒性。