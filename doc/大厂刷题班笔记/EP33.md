## 207题 - 拓扑排序 
### 题目
给定课程总数量以及课程之间的依赖关系，判断是否可以完成所有课程。
### 思路
- 使用拓扑排序来解决问题。
- 构建图结构，记录每个节点的入度和邻居节点。
- 将所有入度为零的节点加入队列。
- 循环弹出队列中的节点，减少其邻居节点的入度，若邻居节点入度降为零，则加入队列。
- 如果最终能处理完所有节点，则可以完成所有课程。

## 210题 - 输出拓扑排序顺序
### 题目
如果可以进行拓扑排序，请输出排序后的顺序。
### 思路
- 基于207题的解法。
- 在每次从队列中弹出节点时，记录该节点。
- 最终收集的所有节点即为拓扑排序的结果。

## 213题 - 打家劫舍问题
### 题目 
给定一个数组，不能取相邻元素，求最大累加和。
### 思路
- 使用动态规划解决。
- 定义状态转移方程：`dp[i] = max(dp[i-1], dp[i-2] + array[i])`。
- 初始化前两个位置的状态。
- 遍历数组，计算每个位置的最大值。
- 返回最后一个位置的值作为结果。

## 237题 - 删除链表中的节点 
### 题目
只给定要删除的节点，不给定头节点，实现删除操作。
### 思路
- 将要删除节点的下一个节点的值复制到当前节点。
- 删除下一个节点。
- 注意此方法无法删除最后一个节点，且实际删除的是下一个节点。

## 238题 - 除自身以外的乘积数组
### 题目 
给定一个数组，返回一个新的数组，其中每个元素是原数组中除自身外所有元素的乘积，要求不使用除法。
### 思路 
- 使用两次遍历，分别计算前缀乘积和后缀乘积。
- 第一次遍历从左向右，计算前缀乘积并存储在结果数组中。
- 第二次遍历从右向左，计算后缀乘积并与前缀乘积相乘得到最终结果。

## 242题 - 判断变形词
### 题目 
给定两个字符串，判断它们是否为变形词（字符种类及每种字符的数量相同）。
### 思路
- 统计两个字符串中每种字符的数量。
- 如果两个字符串长度不同，直接返回false。
- 遍历其中一个字符串的字符数量，与另一个字符串对比。
- 若发现某个字符数量不同或类型不同，返回false；否则返回true。

## 251题 - 二维数组迭代器
### 题目
设计一个类，实现对二维数组的迭代功能，支持`hasNext`和`next`方法。
### 思路
- 使用两个指针表示当前行和列的位置。
- 初始化时将行指针设为0，列指针设为-1。
- 实现`hasNext`方法，检查是否存在未访问的元素。
- 实现`next`方法，返回当前元素并将指针移动到下一个元素。

注意事项
1. 对于拓扑排序问题，注意构建图时正确设置节点的入度和邻居。
2. 动态规划问题中，确保状态转移方程的正确性和初始化的合理性。
3. 链表操作时，注意特殊情况如删除最后一个节点的情况。
4. 乘积数组问题中，避免使用除法，通过前缀和后缀乘积实现。
5. 判断变形词时，注意字符串长度的比较以提高效率。
6. 设计迭代器时，考虑边界条件和多次调用`hasNext`的情况。