## 能获得的最好收入
### 题目 
给定一个数组hard和money，长度都是n。hard[i]表示工作的难度，money[i]表示工作的收入。另有一个能力数组abilities，求每个人能胜任的最大报酬。

### 思路 
- 将工作按照难度排序，相同难度的按报酬降序。
- 删除不必要的工作，只保留每种难度中报酬最高的。
- 建立单调性，删除报酬不变或下降的工作。
- 对于每个人的能力，使用二分法查找其能胜任的最大报酬。

## 06 最短无序连续子数组
### 题目
给定一个数组，只能对其中一个子数组进行排序，求最短需要排序的子数组长度。

### 思路
- 从左到右遍历，记录左边部分的最大值，标记不符合顺序的位置。
- 从右到左遍历，记录右边部分的最小值，标记不符合顺序的位置。
- 最右的违规位置与最左的违规位置之间的子数组即为需要排序的部分。

## 数据结构设计之O(1)实现setAll
### 题目
设计一个哈希表，支持put、get和set all操作，保证这三个操作的时间复杂度为O(1)。

### 思路
- 使用一个时间戳变量time记录每次put的时间。
- set all时记录时间和对应的值。
- get时比较数据的时间戳和set all的时间，选择合适的值返回。

## 一种消息接收并打印的结构设计
### 题目
处理消息流，确保消息按序输出。

### 思路 
- 使用头表和尾表记录连续区间的头尾。
- 当新消息到达时，尝试与已有区间合并。
- 当可以输出时，顺着next指针依次输出并释放内存。

## 买饮料
### 题目 
模拟购买可乐的过程，计算投币次数。

### 思路 
- 按照优先大面值原则进行投币和找零。
- 根据可乐价格和手中钞票数量，计算最少投币次数。
- 注意数据量大，避免直接模拟，利用面值种类少的特点优化算法。

## 阶乘后的零

### 题目

给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1

### 思路



## 司机最高总收入

### 题目

现有司机N * 2人，调度中心会将所有司机平分给A、B两个区域第 i 个司机去A可得收入为income\[i\]\[0\]，第 i 个司机去B可得收入为income\[i\]\[1\]，返回所有调度方案中能使所有司机总收入最高的方案，是多少钱

### 思路

**递归回溯法（MaxMoney1）**

- **核心思想**：通过递归遍历所有可能的分配方案，选择总收入最大的方案。

- 关键点

  - **递归函数** `Process1`：处理从 `index` 开始的司机，剩余 `rest` 个A区域名额时的最大收入。

  - 终止条件

    - 所有司机分配完毕（`index == income.Length`），返回0。
    - 剩余司机必须全部分配到A区域（`income.Length - index == rest`），只能选A。
    - A区域名额已满（`rest == 0`），只能选B。
    
  - **递归逻辑**：当前司机可以选择去A或去B，分别计算两种选择的收入，取最大值。
  
- **缺点**：存在大量重复计算，时间复杂度为指数级（O(2^N)）。

**动态规划（MaxMoney2）**

- **核心思想**：将递归转化为动态规划，避免重复计算，自底向上填充DP表。

- 关键点

  - **DP表定义**：`dp[i, j]` 表示从第 `i` 个司机开始，剩余 `j` 个A区域名额时的最大收入。

  - **填充顺序**：从最后一个司机倒序填充，保证子问题先被解决。

  - 转移方程

    - 剩余司机必须全去A：`dp[i, j] = income[i, 0] + dp[i + 1, j - 1]`。
  - A区域名额已满：`dp[i, j] = income[i, 1] + dp[i + 1, j]`。
    - 否则：取去A或去B的最大值。

- **优点**：时间复杂度降为O(N*M)，空间复杂度O(N*M)，其中M=N/2。

**贪心算法（MaxMoney3）**

- **核心思想**：通过贪心策略快速找到最优解，无需遍历所有可能。

- 关键步骤

  1. **初始假设**：所有司机去A，计算总收入 `sum`。
  2. **计算收益差**：对每个司机，计算去B比去A的额外收益 `arr[i] = income[i,1] - income[i,0]`。
  3. **排序选择**：将收益差排序，选择最大的M个（M=N/2）收益差，加到 `sum` 中。
  
- **优点**：时间复杂度O(N log N)（主要由排序决定），空间复杂度O(N)。

- **适用条件**：依赖问题特性，需证明贪心策略的正确性（本题中贪心成立）。

注意事项

- 在刷题过程中，要理解题目背后的算法思想，而不仅仅是记住解法。
- 对于每个题目，都要自己独立实现代码，并通过多次复述加深印象。
- 刷题后要及时复习，将题目从头到尾梳理一遍，确保理解每一个解题点。
- 理解并掌握课堂中提到的各种数据结构和算法的应用场景及其性能特点。